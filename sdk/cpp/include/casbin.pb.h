// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: casbin.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_casbin_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_casbin_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_casbin_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_casbin_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_casbin_2eproto;
namespace palm {
namespace lily {
namespace v1 {
class Array2DReply;
struct Array2DReplyDefaultTypeInternal;
extern Array2DReplyDefaultTypeInternal _Array2DReply_default_instance_;
class Array2DReply_d;
struct Array2DReply_dDefaultTypeInternal;
extern Array2DReply_dDefaultTypeInternal _Array2DReply_d_default_instance_;
class ArrayReply;
struct ArrayReplyDefaultTypeInternal;
extern ArrayReplyDefaultTypeInternal _ArrayReply_default_instance_;
class BoolReply;
struct BoolReplyDefaultTypeInternal;
extern BoolReplyDefaultTypeInternal _BoolReply_default_instance_;
class EmptyReply;
struct EmptyReplyDefaultTypeInternal;
extern EmptyReplyDefaultTypeInternal _EmptyReply_default_instance_;
class EmptyRequest;
struct EmptyRequestDefaultTypeInternal;
extern EmptyRequestDefaultTypeInternal _EmptyRequest_default_instance_;
class EnforceRequest;
struct EnforceRequestDefaultTypeInternal;
extern EnforceRequestDefaultTypeInternal _EnforceRequest_default_instance_;
class FilteredPolicyRequest;
struct FilteredPolicyRequestDefaultTypeInternal;
extern FilteredPolicyRequestDefaultTypeInternal _FilteredPolicyRequest_default_instance_;
class NewAdapterReply;
struct NewAdapterReplyDefaultTypeInternal;
extern NewAdapterReplyDefaultTypeInternal _NewAdapterReply_default_instance_;
class NewAdapterRequest;
struct NewAdapterRequestDefaultTypeInternal;
extern NewAdapterRequestDefaultTypeInternal _NewAdapterRequest_default_instance_;
class NewEnforcerReply;
struct NewEnforcerReplyDefaultTypeInternal;
extern NewEnforcerReplyDefaultTypeInternal _NewEnforcerReply_default_instance_;
class NewEnforcerRequest;
struct NewEnforcerRequestDefaultTypeInternal;
extern NewEnforcerRequestDefaultTypeInternal _NewEnforcerRequest_default_instance_;
class PermissionRequest;
struct PermissionRequestDefaultTypeInternal;
extern PermissionRequestDefaultTypeInternal _PermissionRequest_default_instance_;
class PolicyRequest;
struct PolicyRequestDefaultTypeInternal;
extern PolicyRequestDefaultTypeInternal _PolicyRequest_default_instance_;
class SimpleGetRequest;
struct SimpleGetRequestDefaultTypeInternal;
extern SimpleGetRequestDefaultTypeInternal _SimpleGetRequest_default_instance_;
class UserRoleRequest;
struct UserRoleRequestDefaultTypeInternal;
extern UserRoleRequestDefaultTypeInternal _UserRoleRequest_default_instance_;
}  // namespace v1
}  // namespace lily
}  // namespace palm
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace palm {
namespace lily {
namespace v1 {

// ===================================================================


// -------------------------------------------------------------------

class UserRoleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.UserRoleRequest) */ {
 public:
  inline UserRoleRequest() : UserRoleRequest(nullptr) {}
  ~UserRoleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UserRoleRequest(::google::protobuf::internal::ConstantInitialized);

  inline UserRoleRequest(const UserRoleRequest& from)
      : UserRoleRequest(nullptr, from) {}
  UserRoleRequest(UserRoleRequest&& from) noexcept
    : UserRoleRequest() {
    *this = ::std::move(from);
  }

  inline UserRoleRequest& operator=(const UserRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserRoleRequest& operator=(UserRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserRoleRequest* internal_default_instance() {
    return reinterpret_cast<const UserRoleRequest*>(
               &_UserRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UserRoleRequest& a, UserRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UserRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserRoleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserRoleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserRoleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserRoleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UserRoleRequest& from) {
    UserRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserRoleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.UserRoleRequest";
  }
  protected:
  explicit UserRoleRequest(::google::protobuf::Arena* arena);
  UserRoleRequest(::google::protobuf::Arena* arena, const UserRoleRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 4,
    kUserFieldNumber = 2,
    kRoleFieldNumber = 3,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string domain = 4;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  const std::string& domain(int index) const;
  std::string* mutable_domain(int index);
  void set_domain(int index, const std::string& value);
  void set_domain(int index, std::string&& value);
  void set_domain(int index, const char* value);
  void set_domain(int index, const char* value, std::size_t size);
  void set_domain(int index, absl::string_view value);
  std::string* add_domain();
  void add_domain(const std::string& value);
  void add_domain(std::string&& value);
  void add_domain(const char* value);
  void add_domain(const char* value, std::size_t size);
  void add_domain(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& domain() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_domain();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_domain() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_domain();

  public:
  // string user = 2;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // string role = 3;
  void clear_role() ;
  const std::string& role() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_role(Arg_&& arg, Args_... args);
  std::string* mutable_role();
  PROTOBUF_NODISCARD std::string* release_role();
  void set_allocated_role(std::string* value);

  private:
  const std::string& _internal_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_role(
      const std::string& value);
  std::string* _internal_mutable_role();

  public:
  // int32 enforcerHandler = 1;
  void clear_enforcerhandler() ;
  ::int32_t enforcerhandler() const;
  void set_enforcerhandler(::int32_t value);

  private:
  ::int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.UserRoleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> domain_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::google::protobuf::internal::ArenaStringPtr role_;
    ::int32_t enforcerhandler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class SimpleGetRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.SimpleGetRequest) */ {
 public:
  inline SimpleGetRequest() : SimpleGetRequest(nullptr) {}
  ~SimpleGetRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SimpleGetRequest(::google::protobuf::internal::ConstantInitialized);

  inline SimpleGetRequest(const SimpleGetRequest& from)
      : SimpleGetRequest(nullptr, from) {}
  SimpleGetRequest(SimpleGetRequest&& from) noexcept
    : SimpleGetRequest() {
    *this = ::std::move(from);
  }

  inline SimpleGetRequest& operator=(const SimpleGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimpleGetRequest& operator=(SimpleGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SimpleGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SimpleGetRequest* internal_default_instance() {
    return reinterpret_cast<const SimpleGetRequest*>(
               &_SimpleGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SimpleGetRequest& a, SimpleGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SimpleGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimpleGetRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SimpleGetRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SimpleGetRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SimpleGetRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SimpleGetRequest& from) {
    SimpleGetRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SimpleGetRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.SimpleGetRequest";
  }
  protected:
  explicit SimpleGetRequest(::google::protobuf::Arena* arena);
  SimpleGetRequest(::google::protobuf::Arena* arena, const SimpleGetRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPTypeFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // string pType = 2;
  void clear_ptype() ;
  const std::string& ptype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ptype(Arg_&& arg, Args_... args);
  std::string* mutable_ptype();
  PROTOBUF_NODISCARD std::string* release_ptype();
  void set_allocated_ptype(std::string* value);

  private:
  const std::string& _internal_ptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ptype(
      const std::string& value);
  std::string* _internal_mutable_ptype();

  public:
  // int32 enforcerHandler = 1;
  void clear_enforcerhandler() ;
  ::int32_t enforcerhandler() const;
  void set_enforcerhandler(::int32_t value);

  private:
  ::int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.SimpleGetRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr ptype_;
    ::int32_t enforcerhandler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class PolicyRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.PolicyRequest) */ {
 public:
  inline PolicyRequest() : PolicyRequest(nullptr) {}
  ~PolicyRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PolicyRequest(::google::protobuf::internal::ConstantInitialized);

  inline PolicyRequest(const PolicyRequest& from)
      : PolicyRequest(nullptr, from) {}
  PolicyRequest(PolicyRequest&& from) noexcept
    : PolicyRequest() {
    *this = ::std::move(from);
  }

  inline PolicyRequest& operator=(const PolicyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PolicyRequest& operator=(PolicyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PolicyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PolicyRequest* internal_default_instance() {
    return reinterpret_cast<const PolicyRequest*>(
               &_PolicyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PolicyRequest& a, PolicyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PolicyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PolicyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PolicyRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PolicyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PolicyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PolicyRequest& from) {
    PolicyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PolicyRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.PolicyRequest";
  }
  protected:
  explicit PolicyRequest(::google::protobuf::Arena* arena);
  PolicyRequest(::google::protobuf::Arena* arena, const PolicyRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 3,
    kPTypeFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string params = 3;
  int params_size() const;
  private:
  int _internal_params_size() const;

  public:
  void clear_params() ;
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, std::size_t size);
  void set_params(int index, absl::string_view value);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const char* value, std::size_t size);
  void add_params(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& params() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_params();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_params() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_params();

  public:
  // string pType = 2;
  void clear_ptype() ;
  const std::string& ptype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ptype(Arg_&& arg, Args_... args);
  std::string* mutable_ptype();
  PROTOBUF_NODISCARD std::string* release_ptype();
  void set_allocated_ptype(std::string* value);

  private:
  const std::string& _internal_ptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ptype(
      const std::string& value);
  std::string* _internal_mutable_ptype();

  public:
  // int32 enforcerHandler = 1;
  void clear_enforcerhandler() ;
  ::int32_t enforcerhandler() const;
  void set_enforcerhandler(::int32_t value);

  private:
  ::int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.PolicyRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> params_;
    ::google::protobuf::internal::ArenaStringPtr ptype_;
    ::int32_t enforcerhandler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class PermissionRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.PermissionRequest) */ {
 public:
  inline PermissionRequest() : PermissionRequest(nullptr) {}
  ~PermissionRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PermissionRequest(::google::protobuf::internal::ConstantInitialized);

  inline PermissionRequest(const PermissionRequest& from)
      : PermissionRequest(nullptr, from) {}
  PermissionRequest(PermissionRequest&& from) noexcept
    : PermissionRequest() {
    *this = ::std::move(from);
  }

  inline PermissionRequest& operator=(const PermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PermissionRequest& operator=(PermissionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PermissionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PermissionRequest* internal_default_instance() {
    return reinterpret_cast<const PermissionRequest*>(
               &_PermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PermissionRequest& a, PermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PermissionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PermissionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PermissionRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PermissionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PermissionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PermissionRequest& from) {
    PermissionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PermissionRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.PermissionRequest";
  }
  protected:
  explicit PermissionRequest(::google::protobuf::Arena* arena);
  PermissionRequest(::google::protobuf::Arena* arena, const PermissionRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 3,
    kDomainFieldNumber = 4,
    kUserFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string permissions = 3;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;

  public:
  void clear_permissions() ;
  const std::string& permissions(int index) const;
  std::string* mutable_permissions(int index);
  void set_permissions(int index, const std::string& value);
  void set_permissions(int index, std::string&& value);
  void set_permissions(int index, const char* value);
  void set_permissions(int index, const char* value, std::size_t size);
  void set_permissions(int index, absl::string_view value);
  std::string* add_permissions();
  void add_permissions(const std::string& value);
  void add_permissions(std::string&& value);
  void add_permissions(const char* value);
  void add_permissions(const char* value, std::size_t size);
  void add_permissions(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& permissions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_permissions();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_permissions() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_permissions();

  public:
  // repeated string domain = 4;
  int domain_size() const;
  private:
  int _internal_domain_size() const;

  public:
  void clear_domain() ;
  const std::string& domain(int index) const;
  std::string* mutable_domain(int index);
  void set_domain(int index, const std::string& value);
  void set_domain(int index, std::string&& value);
  void set_domain(int index, const char* value);
  void set_domain(int index, const char* value, std::size_t size);
  void set_domain(int index, absl::string_view value);
  std::string* add_domain();
  void add_domain(const std::string& value);
  void add_domain(std::string&& value);
  void add_domain(const char* value);
  void add_domain(const char* value, std::size_t size);
  void add_domain(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& domain() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_domain();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_domain() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_domain();

  public:
  // string user = 2;
  void clear_user() ;
  const std::string& user() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* value);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // int32 enforcerHandler = 1;
  void clear_enforcerhandler() ;
  ::int32_t enforcerhandler() const;
  void set_enforcerhandler(::int32_t value);

  private:
  ::int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.PermissionRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      60, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> permissions_;
    ::google::protobuf::RepeatedPtrField<std::string> domain_;
    ::google::protobuf::internal::ArenaStringPtr user_;
    ::int32_t enforcerhandler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class NewEnforcerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.NewEnforcerRequest) */ {
 public:
  inline NewEnforcerRequest() : NewEnforcerRequest(nullptr) {}
  ~NewEnforcerRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NewEnforcerRequest(::google::protobuf::internal::ConstantInitialized);

  inline NewEnforcerRequest(const NewEnforcerRequest& from)
      : NewEnforcerRequest(nullptr, from) {}
  NewEnforcerRequest(NewEnforcerRequest&& from) noexcept
    : NewEnforcerRequest() {
    *this = ::std::move(from);
  }

  inline NewEnforcerRequest& operator=(const NewEnforcerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewEnforcerRequest& operator=(NewEnforcerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewEnforcerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewEnforcerRequest* internal_default_instance() {
    return reinterpret_cast<const NewEnforcerRequest*>(
               &_NewEnforcerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NewEnforcerRequest& a, NewEnforcerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewEnforcerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewEnforcerRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewEnforcerRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewEnforcerRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NewEnforcerRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NewEnforcerRequest& from) {
    NewEnforcerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NewEnforcerRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.NewEnforcerRequest";
  }
  protected:
  explicit NewEnforcerRequest(::google::protobuf::Arena* arena);
  NewEnforcerRequest(::google::protobuf::Arena* arena, const NewEnforcerRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelTextFieldNumber = 1,
    kAdapterHandleFieldNumber = 2,
  };
  // string modelText = 1;
  void clear_modeltext() ;
  const std::string& modeltext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_modeltext(Arg_&& arg, Args_... args);
  std::string* mutable_modeltext();
  PROTOBUF_NODISCARD std::string* release_modeltext();
  void set_allocated_modeltext(std::string* value);

  private:
  const std::string& _internal_modeltext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modeltext(
      const std::string& value);
  std::string* _internal_mutable_modeltext();

  public:
  // int32 adapterHandle = 2;
  void clear_adapterhandle() ;
  ::int32_t adapterhandle() const;
  void set_adapterhandle(::int32_t value);

  private:
  ::int32_t _internal_adapterhandle() const;
  void _internal_set_adapterhandle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.NewEnforcerRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr modeltext_;
    ::int32_t adapterhandle_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class NewEnforcerReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.NewEnforcerReply) */ {
 public:
  inline NewEnforcerReply() : NewEnforcerReply(nullptr) {}
  ~NewEnforcerReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NewEnforcerReply(::google::protobuf::internal::ConstantInitialized);

  inline NewEnforcerReply(const NewEnforcerReply& from)
      : NewEnforcerReply(nullptr, from) {}
  NewEnforcerReply(NewEnforcerReply&& from) noexcept
    : NewEnforcerReply() {
    *this = ::std::move(from);
  }

  inline NewEnforcerReply& operator=(const NewEnforcerReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewEnforcerReply& operator=(NewEnforcerReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewEnforcerReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewEnforcerReply* internal_default_instance() {
    return reinterpret_cast<const NewEnforcerReply*>(
               &_NewEnforcerReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NewEnforcerReply& a, NewEnforcerReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NewEnforcerReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewEnforcerReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewEnforcerReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewEnforcerReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NewEnforcerReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NewEnforcerReply& from) {
    NewEnforcerReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NewEnforcerReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.NewEnforcerReply";
  }
  protected:
  explicit NewEnforcerReply(::google::protobuf::Arena* arena);
  NewEnforcerReply(::google::protobuf::Arena* arena, const NewEnforcerReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
  };
  // int32 handler = 1;
  void clear_handler() ;
  ::int32_t handler() const;
  void set_handler(::int32_t value);

  private:
  ::int32_t _internal_handler() const;
  void _internal_set_handler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.NewEnforcerReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t handler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class NewAdapterRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.NewAdapterRequest) */ {
 public:
  inline NewAdapterRequest() : NewAdapterRequest(nullptr) {}
  ~NewAdapterRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NewAdapterRequest(::google::protobuf::internal::ConstantInitialized);

  inline NewAdapterRequest(const NewAdapterRequest& from)
      : NewAdapterRequest(nullptr, from) {}
  NewAdapterRequest(NewAdapterRequest&& from) noexcept
    : NewAdapterRequest() {
    *this = ::std::move(from);
  }

  inline NewAdapterRequest& operator=(const NewAdapterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAdapterRequest& operator=(NewAdapterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAdapterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAdapterRequest* internal_default_instance() {
    return reinterpret_cast<const NewAdapterRequest*>(
               &_NewAdapterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NewAdapterRequest& a, NewAdapterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAdapterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAdapterRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAdapterRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAdapterRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NewAdapterRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NewAdapterRequest& from) {
    NewAdapterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NewAdapterRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.NewAdapterRequest";
  }
  protected:
  explicit NewAdapterRequest(::google::protobuf::Arena* arena);
  NewAdapterRequest(::google::protobuf::Arena* arena, const NewAdapterRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdapterNameFieldNumber = 1,
    kDriverNameFieldNumber = 2,
    kConnectStringFieldNumber = 3,
    kDbSpecifiedFieldNumber = 4,
  };
  // string adapterName = 1;
  void clear_adaptername() ;
  const std::string& adaptername() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_adaptername(Arg_&& arg, Args_... args);
  std::string* mutable_adaptername();
  PROTOBUF_NODISCARD std::string* release_adaptername();
  void set_allocated_adaptername(std::string* value);

  private:
  const std::string& _internal_adaptername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_adaptername(
      const std::string& value);
  std::string* _internal_mutable_adaptername();

  public:
  // string driverName = 2;
  void clear_drivername() ;
  const std::string& drivername() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_drivername(Arg_&& arg, Args_... args);
  std::string* mutable_drivername();
  PROTOBUF_NODISCARD std::string* release_drivername();
  void set_allocated_drivername(std::string* value);

  private:
  const std::string& _internal_drivername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_drivername(
      const std::string& value);
  std::string* _internal_mutable_drivername();

  public:
  // string connectString = 3;
  void clear_connectstring() ;
  const std::string& connectstring() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connectstring(Arg_&& arg, Args_... args);
  std::string* mutable_connectstring();
  PROTOBUF_NODISCARD std::string* release_connectstring();
  void set_allocated_connectstring(std::string* value);

  private:
  const std::string& _internal_connectstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectstring(
      const std::string& value);
  std::string* _internal_mutable_connectstring();

  public:
  // bool dbSpecified = 4;
  void clear_dbspecified() ;
  bool dbspecified() const;
  void set_dbspecified(bool value);

  private:
  bool _internal_dbspecified() const;
  void _internal_set_dbspecified(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.NewAdapterRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr adaptername_;
    ::google::protobuf::internal::ArenaStringPtr drivername_;
    ::google::protobuf::internal::ArenaStringPtr connectstring_;
    bool dbspecified_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class NewAdapterReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.NewAdapterReply) */ {
 public:
  inline NewAdapterReply() : NewAdapterReply(nullptr) {}
  ~NewAdapterReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NewAdapterReply(::google::protobuf::internal::ConstantInitialized);

  inline NewAdapterReply(const NewAdapterReply& from)
      : NewAdapterReply(nullptr, from) {}
  NewAdapterReply(NewAdapterReply&& from) noexcept
    : NewAdapterReply() {
    *this = ::std::move(from);
  }

  inline NewAdapterReply& operator=(const NewAdapterReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewAdapterReply& operator=(NewAdapterReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewAdapterReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewAdapterReply* internal_default_instance() {
    return reinterpret_cast<const NewAdapterReply*>(
               &_NewAdapterReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(NewAdapterReply& a, NewAdapterReply& b) {
    a.Swap(&b);
  }
  inline void Swap(NewAdapterReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewAdapterReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewAdapterReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewAdapterReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NewAdapterReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NewAdapterReply& from) {
    NewAdapterReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NewAdapterReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.NewAdapterReply";
  }
  protected:
  explicit NewAdapterReply(::google::protobuf::Arena* arena);
  NewAdapterReply(::google::protobuf::Arena* arena, const NewAdapterReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
  };
  // int32 handler = 1;
  void clear_handler() ;
  ::int32_t handler() const;
  void set_handler(::int32_t value);

  private:
  ::int32_t _internal_handler() const;
  void _internal_set_handler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.NewAdapterReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t handler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class FilteredPolicyRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.FilteredPolicyRequest) */ {
 public:
  inline FilteredPolicyRequest() : FilteredPolicyRequest(nullptr) {}
  ~FilteredPolicyRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FilteredPolicyRequest(::google::protobuf::internal::ConstantInitialized);

  inline FilteredPolicyRequest(const FilteredPolicyRequest& from)
      : FilteredPolicyRequest(nullptr, from) {}
  FilteredPolicyRequest(FilteredPolicyRequest&& from) noexcept
    : FilteredPolicyRequest() {
    *this = ::std::move(from);
  }

  inline FilteredPolicyRequest& operator=(const FilteredPolicyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilteredPolicyRequest& operator=(FilteredPolicyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilteredPolicyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilteredPolicyRequest* internal_default_instance() {
    return reinterpret_cast<const FilteredPolicyRequest*>(
               &_FilteredPolicyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FilteredPolicyRequest& a, FilteredPolicyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FilteredPolicyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilteredPolicyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilteredPolicyRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilteredPolicyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FilteredPolicyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FilteredPolicyRequest& from) {
    FilteredPolicyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FilteredPolicyRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.FilteredPolicyRequest";
  }
  protected:
  explicit FilteredPolicyRequest(::google::protobuf::Arena* arena);
  FilteredPolicyRequest(::google::protobuf::Arena* arena, const FilteredPolicyRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldValuesFieldNumber = 4,
    kPTypeFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
    kFieldIndexFieldNumber = 3,
  };
  // repeated string fieldValues = 4;
  int fieldvalues_size() const;
  private:
  int _internal_fieldvalues_size() const;

  public:
  void clear_fieldvalues() ;
  const std::string& fieldvalues(int index) const;
  std::string* mutable_fieldvalues(int index);
  void set_fieldvalues(int index, const std::string& value);
  void set_fieldvalues(int index, std::string&& value);
  void set_fieldvalues(int index, const char* value);
  void set_fieldvalues(int index, const char* value, std::size_t size);
  void set_fieldvalues(int index, absl::string_view value);
  std::string* add_fieldvalues();
  void add_fieldvalues(const std::string& value);
  void add_fieldvalues(std::string&& value);
  void add_fieldvalues(const char* value);
  void add_fieldvalues(const char* value, std::size_t size);
  void add_fieldvalues(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& fieldvalues() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_fieldvalues();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_fieldvalues() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_fieldvalues();

  public:
  // string pType = 2;
  void clear_ptype() ;
  const std::string& ptype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ptype(Arg_&& arg, Args_... args);
  std::string* mutable_ptype();
  PROTOBUF_NODISCARD std::string* release_ptype();
  void set_allocated_ptype(std::string* value);

  private:
  const std::string& _internal_ptype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ptype(
      const std::string& value);
  std::string* _internal_mutable_ptype();

  public:
  // int32 enforcerHandler = 1;
  void clear_enforcerhandler() ;
  ::int32_t enforcerhandler() const;
  void set_enforcerhandler(::int32_t value);

  private:
  ::int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(::int32_t value);

  public:
  // int32 fieldIndex = 3;
  void clear_fieldindex() ;
  ::int32_t fieldindex() const;
  void set_fieldindex(::int32_t value);

  private:
  ::int32_t _internal_fieldindex() const;
  void _internal_set_fieldindex(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.FilteredPolicyRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> fieldvalues_;
    ::google::protobuf::internal::ArenaStringPtr ptype_;
    ::int32_t enforcerhandler_;
    ::int32_t fieldindex_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class EnforceRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.EnforceRequest) */ {
 public:
  inline EnforceRequest() : EnforceRequest(nullptr) {}
  ~EnforceRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EnforceRequest(::google::protobuf::internal::ConstantInitialized);

  inline EnforceRequest(const EnforceRequest& from)
      : EnforceRequest(nullptr, from) {}
  EnforceRequest(EnforceRequest&& from) noexcept
    : EnforceRequest() {
    *this = ::std::move(from);
  }

  inline EnforceRequest& operator=(const EnforceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnforceRequest& operator=(EnforceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnforceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnforceRequest* internal_default_instance() {
    return reinterpret_cast<const EnforceRequest*>(
               &_EnforceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EnforceRequest& a, EnforceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnforceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnforceRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnforceRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnforceRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnforceRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EnforceRequest& from) {
    EnforceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EnforceRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.EnforceRequest";
  }
  protected:
  explicit EnforceRequest(::google::protobuf::Arena* arena);
  EnforceRequest(::google::protobuf::Arena* arena, const EnforceRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kEnforcerHandlerFieldNumber = 1,
  };
  // repeated string params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;

  public:
  void clear_params() ;
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, std::size_t size);
  void set_params(int index, absl::string_view value);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const char* value, std::size_t size);
  void add_params(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& params() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_params();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_params() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_params();

  public:
  // int32 enforcerHandler = 1;
  void clear_enforcerhandler() ;
  ::int32_t enforcerhandler() const;
  void set_enforcerhandler(::int32_t value);

  private:
  ::int32_t _internal_enforcerhandler() const;
  void _internal_set_enforcerhandler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.EnforceRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> params_;
    ::int32_t enforcerhandler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class EmptyRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.EmptyRequest) */ {
 public:
  inline EmptyRequest() : EmptyRequest(nullptr) {}
  ~EmptyRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyRequest(::google::protobuf::internal::ConstantInitialized);

  inline EmptyRequest(const EmptyRequest& from)
      : EmptyRequest(nullptr, from) {}
  EmptyRequest(EmptyRequest&& from) noexcept
    : EmptyRequest() {
    *this = ::std::move(from);
  }

  inline EmptyRequest& operator=(const EmptyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyRequest& operator=(EmptyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyRequest*>(
               &_EmptyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EmptyRequest& a, EmptyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmptyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EmptyRequest& from) {
    EmptyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmptyRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.EmptyRequest";
  }
  protected:
  explicit EmptyRequest(::google::protobuf::Arena* arena);
  EmptyRequest(::google::protobuf::Arena* arena, const EmptyRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandlerFieldNumber = 1,
  };
  // int32 handler = 1;
  void clear_handler() ;
  ::int32_t handler() const;
  void set_handler(::int32_t value);

  private:
  ::int32_t _internal_handler() const;
  void _internal_set_handler(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.EmptyRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t handler_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class EmptyReply final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:palm.lily.v1.EmptyReply) */ {
 public:
  inline EmptyReply() : EmptyReply(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyReply(::google::protobuf::internal::ConstantInitialized);

  inline EmptyReply(const EmptyReply& from)
      : EmptyReply(nullptr, from) {}
  EmptyReply(EmptyReply&& from) noexcept
    : EmptyReply() {
    *this = ::std::move(from);
  }

  inline EmptyReply& operator=(const EmptyReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyReply& operator=(EmptyReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyReply* internal_default_instance() {
    return reinterpret_cast<const EmptyReply*>(
               &_EmptyReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EmptyReply& a, EmptyReply& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyReply>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyReply& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyReply& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.EmptyReply";
  }
  protected:
  explicit EmptyReply(::google::protobuf::Arena* arena);
  EmptyReply(::google::protobuf::Arena* arena, const EmptyReply& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:palm.lily.v1.EmptyReply)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class BoolReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.BoolReply) */ {
 public:
  inline BoolReply() : BoolReply(nullptr) {}
  ~BoolReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolReply(::google::protobuf::internal::ConstantInitialized);

  inline BoolReply(const BoolReply& from)
      : BoolReply(nullptr, from) {}
  BoolReply(BoolReply&& from) noexcept
    : BoolReply() {
    *this = ::std::move(from);
  }

  inline BoolReply& operator=(const BoolReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolReply& operator=(BoolReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolReply* internal_default_instance() {
    return reinterpret_cast<const BoolReply*>(
               &_BoolReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BoolReply& a, BoolReply& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolReply& from) {
    BoolReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BoolReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.BoolReply";
  }
  protected:
  explicit BoolReply(::google::protobuf::Arena* arena);
  BoolReply(::google::protobuf::Arena* arena, const BoolReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResFieldNumber = 1,
  };
  // bool res = 1;
  void clear_res() ;
  bool res() const;
  void set_res(bool value);

  private:
  bool _internal_res() const;
  void _internal_set_res(bool value);

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.BoolReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool res_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class ArrayReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.ArrayReply) */ {
 public:
  inline ArrayReply() : ArrayReply(nullptr) {}
  ~ArrayReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ArrayReply(::google::protobuf::internal::ConstantInitialized);

  inline ArrayReply(const ArrayReply& from)
      : ArrayReply(nullptr, from) {}
  ArrayReply(ArrayReply&& from) noexcept
    : ArrayReply() {
    *this = ::std::move(from);
  }

  inline ArrayReply& operator=(const ArrayReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ArrayReply& operator=(ArrayReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ArrayReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ArrayReply* internal_default_instance() {
    return reinterpret_cast<const ArrayReply*>(
               &_ArrayReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ArrayReply& a, ArrayReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ArrayReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ArrayReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ArrayReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ArrayReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ArrayReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ArrayReply& from) {
    ArrayReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ArrayReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.ArrayReply";
  }
  protected:
  explicit ArrayReply(::google::protobuf::Arena* arena);
  ArrayReply(::google::protobuf::Arena* arena, const ArrayReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrayFieldNumber = 1,
  };
  // repeated string array = 1;
  int array_size() const;
  private:
  int _internal_array_size() const;

  public:
  void clear_array() ;
  const std::string& array(int index) const;
  std::string* mutable_array(int index);
  void set_array(int index, const std::string& value);
  void set_array(int index, std::string&& value);
  void set_array(int index, const char* value);
  void set_array(int index, const char* value, std::size_t size);
  void set_array(int index, absl::string_view value);
  std::string* add_array();
  void add_array(const std::string& value);
  void add_array(std::string&& value);
  void add_array(const char* value);
  void add_array(const char* value, std::size_t size);
  void add_array(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& array() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_array();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_array() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_array();

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.ArrayReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> array_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class Array2DReply_d final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.Array2DReply.d) */ {
 public:
  inline Array2DReply_d() : Array2DReply_d(nullptr) {}
  ~Array2DReply_d() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Array2DReply_d(::google::protobuf::internal::ConstantInitialized);

  inline Array2DReply_d(const Array2DReply_d& from)
      : Array2DReply_d(nullptr, from) {}
  Array2DReply_d(Array2DReply_d&& from) noexcept
    : Array2DReply_d() {
    *this = ::std::move(from);
  }

  inline Array2DReply_d& operator=(const Array2DReply_d& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array2DReply_d& operator=(Array2DReply_d&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array2DReply_d& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array2DReply_d* internal_default_instance() {
    return reinterpret_cast<const Array2DReply_d*>(
               &_Array2DReply_d_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Array2DReply_d& a, Array2DReply_d& b) {
    a.Swap(&b);
  }
  inline void Swap(Array2DReply_d* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array2DReply_d* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array2DReply_d* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array2DReply_d>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Array2DReply_d& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Array2DReply_d& from) {
    Array2DReply_d::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Array2DReply_d* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.Array2DReply.d";
  }
  protected:
  explicit Array2DReply_d(::google::protobuf::Arena* arena);
  Array2DReply_d(::google::protobuf::Arena* arena, const Array2DReply_d& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kD1FieldNumber = 1,
  };
  // repeated string d1 = 1;
  int d1_size() const;
  private:
  int _internal_d1_size() const;

  public:
  void clear_d1() ;
  const std::string& d1(int index) const;
  std::string* mutable_d1(int index);
  void set_d1(int index, const std::string& value);
  void set_d1(int index, std::string&& value);
  void set_d1(int index, const char* value);
  void set_d1(int index, const char* value, std::size_t size);
  void set_d1(int index, absl::string_view value);
  std::string* add_d1();
  void add_d1(const std::string& value);
  void add_d1(std::string&& value);
  void add_d1(const char* value);
  void add_d1(const char* value, std::size_t size);
  void add_d1(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& d1() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_d1();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_d1() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_d1();

  public:
  // @@protoc_insertion_point(class_scope:palm.lily.v1.Array2DReply.d)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> d1_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};// -------------------------------------------------------------------

class Array2DReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:palm.lily.v1.Array2DReply) */ {
 public:
  inline Array2DReply() : Array2DReply(nullptr) {}
  ~Array2DReply() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Array2DReply(::google::protobuf::internal::ConstantInitialized);

  inline Array2DReply(const Array2DReply& from)
      : Array2DReply(nullptr, from) {}
  Array2DReply(Array2DReply&& from) noexcept
    : Array2DReply() {
    *this = ::std::move(from);
  }

  inline Array2DReply& operator=(const Array2DReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline Array2DReply& operator=(Array2DReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Array2DReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const Array2DReply* internal_default_instance() {
    return reinterpret_cast<const Array2DReply*>(
               &_Array2DReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Array2DReply& a, Array2DReply& b) {
    a.Swap(&b);
  }
  inline void Swap(Array2DReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Array2DReply* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Array2DReply* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Array2DReply>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Array2DReply& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Array2DReply& from) {
    Array2DReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Array2DReply* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "palm.lily.v1.Array2DReply";
  }
  protected:
  explicit Array2DReply(::google::protobuf::Arena* arena);
  Array2DReply(::google::protobuf::Arena* arena, const Array2DReply& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using d = Array2DReply_d;

  // accessors -------------------------------------------------------

  enum : int {
    kD2FieldNumber = 1,
  };
  // repeated .palm.lily.v1.Array2DReply.d d2 = 1;
  int d2_size() const;
  private:
  int _internal_d2_size() const;

  public:
  void clear_d2() ;
  ::palm::lily::v1::Array2DReply_d* mutable_d2(int index);
  ::google::protobuf::RepeatedPtrField< ::palm::lily::v1::Array2DReply_d >*
      mutable_d2();
  private:
  const ::google::protobuf::RepeatedPtrField<::palm::lily::v1::Array2DReply_d>& _internal_d2() const;
  ::google::protobuf::RepeatedPtrField<::palm::lily::v1::Array2DReply_d>* _internal_mutable_d2();
  public:
  const ::palm::lily::v1::Array2DReply_d& d2(int index) const;
  ::palm::lily::v1::Array2DReply_d* add_d2();
  const ::google::protobuf::RepeatedPtrField< ::palm::lily::v1::Array2DReply_d >&
      d2() const;
  // @@protoc_insertion_point(class_scope:palm.lily.v1.Array2DReply)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::palm::lily::v1::Array2DReply_d > d2_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_casbin_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NewEnforcerRequest

// string modelText = 1;
inline void NewEnforcerRequest::clear_modeltext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modeltext_.ClearToEmpty();
}
inline const std::string& NewEnforcerRequest::modeltext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewEnforcerRequest.modelText)
  return _internal_modeltext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NewEnforcerRequest::set_modeltext(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.modeltext_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewEnforcerRequest.modelText)
}
inline std::string* NewEnforcerRequest::mutable_modeltext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_modeltext();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.NewEnforcerRequest.modelText)
  return _s;
}
inline const std::string& NewEnforcerRequest::_internal_modeltext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.modeltext_.Get();
}
inline void NewEnforcerRequest::_internal_set_modeltext(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.modeltext_.Set(value, GetArena());
}
inline std::string* NewEnforcerRequest::_internal_mutable_modeltext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.modeltext_.Mutable( GetArena());
}
inline std::string* NewEnforcerRequest::release_modeltext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.NewEnforcerRequest.modelText)
  return _impl_.modeltext_.Release();
}
inline void NewEnforcerRequest::set_allocated_modeltext(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.modeltext_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.modeltext_.IsDefault()) {
          _impl_.modeltext_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.NewEnforcerRequest.modelText)
}

// int32 adapterHandle = 2;
inline void NewEnforcerRequest::clear_adapterhandle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.adapterhandle_ = 0;
}
inline ::int32_t NewEnforcerRequest::adapterhandle() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewEnforcerRequest.adapterHandle)
  return _internal_adapterhandle();
}
inline void NewEnforcerRequest::set_adapterhandle(::int32_t value) {
  _internal_set_adapterhandle(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewEnforcerRequest.adapterHandle)
}
inline ::int32_t NewEnforcerRequest::_internal_adapterhandle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.adapterhandle_;
}
inline void NewEnforcerRequest::_internal_set_adapterhandle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.adapterhandle_ = value;
}

// -------------------------------------------------------------------

// NewEnforcerReply

// int32 handler = 1;
inline void NewEnforcerReply::clear_handler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.handler_ = 0;
}
inline ::int32_t NewEnforcerReply::handler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewEnforcerReply.handler)
  return _internal_handler();
}
inline void NewEnforcerReply::set_handler(::int32_t value) {
  _internal_set_handler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewEnforcerReply.handler)
}
inline ::int32_t NewEnforcerReply::_internal_handler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.handler_;
}
inline void NewEnforcerReply::_internal_set_handler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.handler_ = value;
}

// -------------------------------------------------------------------

// NewAdapterRequest

// string adapterName = 1;
inline void NewAdapterRequest::clear_adaptername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.adaptername_.ClearToEmpty();
}
inline const std::string& NewAdapterRequest::adaptername() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewAdapterRequest.adapterName)
  return _internal_adaptername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NewAdapterRequest::set_adaptername(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.adaptername_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewAdapterRequest.adapterName)
}
inline std::string* NewAdapterRequest::mutable_adaptername() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_adaptername();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.NewAdapterRequest.adapterName)
  return _s;
}
inline const std::string& NewAdapterRequest::_internal_adaptername() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.adaptername_.Get();
}
inline void NewAdapterRequest::_internal_set_adaptername(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.adaptername_.Set(value, GetArena());
}
inline std::string* NewAdapterRequest::_internal_mutable_adaptername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.adaptername_.Mutable( GetArena());
}
inline std::string* NewAdapterRequest::release_adaptername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.NewAdapterRequest.adapterName)
  return _impl_.adaptername_.Release();
}
inline void NewAdapterRequest::set_allocated_adaptername(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.adaptername_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.adaptername_.IsDefault()) {
          _impl_.adaptername_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.NewAdapterRequest.adapterName)
}

// string driverName = 2;
inline void NewAdapterRequest::clear_drivername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drivername_.ClearToEmpty();
}
inline const std::string& NewAdapterRequest::drivername() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewAdapterRequest.driverName)
  return _internal_drivername();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NewAdapterRequest::set_drivername(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.drivername_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewAdapterRequest.driverName)
}
inline std::string* NewAdapterRequest::mutable_drivername() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_drivername();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.NewAdapterRequest.driverName)
  return _s;
}
inline const std::string& NewAdapterRequest::_internal_drivername() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.drivername_.Get();
}
inline void NewAdapterRequest::_internal_set_drivername(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.drivername_.Set(value, GetArena());
}
inline std::string* NewAdapterRequest::_internal_mutable_drivername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.drivername_.Mutable( GetArena());
}
inline std::string* NewAdapterRequest::release_drivername() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.NewAdapterRequest.driverName)
  return _impl_.drivername_.Release();
}
inline void NewAdapterRequest::set_allocated_drivername(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.drivername_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.drivername_.IsDefault()) {
          _impl_.drivername_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.NewAdapterRequest.driverName)
}

// string connectString = 3;
inline void NewAdapterRequest::clear_connectstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectstring_.ClearToEmpty();
}
inline const std::string& NewAdapterRequest::connectstring() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewAdapterRequest.connectString)
  return _internal_connectstring();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NewAdapterRequest::set_connectstring(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectstring_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewAdapterRequest.connectString)
}
inline std::string* NewAdapterRequest::mutable_connectstring() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connectstring();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.NewAdapterRequest.connectString)
  return _s;
}
inline const std::string& NewAdapterRequest::_internal_connectstring() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.connectstring_.Get();
}
inline void NewAdapterRequest::_internal_set_connectstring(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.connectstring_.Set(value, GetArena());
}
inline std::string* NewAdapterRequest::_internal_mutable_connectstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.connectstring_.Mutable( GetArena());
}
inline std::string* NewAdapterRequest::release_connectstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.NewAdapterRequest.connectString)
  return _impl_.connectstring_.Release();
}
inline void NewAdapterRequest::set_allocated_connectstring(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.connectstring_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connectstring_.IsDefault()) {
          _impl_.connectstring_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.NewAdapterRequest.connectString)
}

// bool dbSpecified = 4;
inline void NewAdapterRequest::clear_dbspecified() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dbspecified_ = false;
}
inline bool NewAdapterRequest::dbspecified() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewAdapterRequest.dbSpecified)
  return _internal_dbspecified();
}
inline void NewAdapterRequest::set_dbspecified(bool value) {
  _internal_set_dbspecified(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewAdapterRequest.dbSpecified)
}
inline bool NewAdapterRequest::_internal_dbspecified() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dbspecified_;
}
inline void NewAdapterRequest::_internal_set_dbspecified(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dbspecified_ = value;
}

// -------------------------------------------------------------------

// NewAdapterReply

// int32 handler = 1;
inline void NewAdapterReply::clear_handler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.handler_ = 0;
}
inline ::int32_t NewAdapterReply::handler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.NewAdapterReply.handler)
  return _internal_handler();
}
inline void NewAdapterReply::set_handler(::int32_t value) {
  _internal_set_handler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.NewAdapterReply.handler)
}
inline ::int32_t NewAdapterReply::_internal_handler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.handler_;
}
inline void NewAdapterReply::_internal_set_handler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.handler_ = value;
}

// -------------------------------------------------------------------

// EnforceRequest

// int32 enforcerHandler = 1;
inline void EnforceRequest::clear_enforcerhandler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enforcerhandler_ = 0;
}
inline ::int32_t EnforceRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.EnforceRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void EnforceRequest::set_enforcerhandler(::int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.EnforceRequest.enforcerHandler)
}
inline ::int32_t EnforceRequest::_internal_enforcerhandler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enforcerhandler_;
}
inline void EnforceRequest::_internal_set_enforcerhandler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enforcerhandler_ = value;
}

// repeated string params = 2;
inline int EnforceRequest::_internal_params_size() const {
  return _internal_params().size();
}
inline int EnforceRequest::params_size() const {
  return _internal_params_size();
}
inline void EnforceRequest::clear_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.params_.Clear();
}
inline std::string* EnforceRequest::add_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_params()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.EnforceRequest.params)
  return _s;
}
inline const std::string& EnforceRequest::params(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.EnforceRequest.params)
  return _internal_params().Get(index);
}
inline std::string* EnforceRequest::mutable_params(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.EnforceRequest.params)
  return _internal_mutable_params()->Mutable(index);
}
inline void EnforceRequest::set_params(int index, const std::string& value) {
  _internal_mutable_params()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, std::string&& value) {
  _internal_mutable_params()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_params()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_params()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::set_params(int index, absl::string_view value) {
  _internal_mutable_params()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.EnforceRequest.params)
}
inline void EnforceRequest::add_params(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.EnforceRequest.params)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
EnforceRequest::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.EnforceRequest.params)
  return _internal_params();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
EnforceRequest::mutable_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.EnforceRequest.params)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_params();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
EnforceRequest::_internal_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.params_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
EnforceRequest::_internal_mutable_params() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.params_;
}

// -------------------------------------------------------------------

// BoolReply

// bool res = 1;
inline void BoolReply::clear_res() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.res_ = false;
}
inline bool BoolReply::res() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.BoolReply.res)
  return _internal_res();
}
inline void BoolReply::set_res(bool value) {
  _internal_set_res(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.BoolReply.res)
}
inline bool BoolReply::_internal_res() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.res_;
}
inline void BoolReply::_internal_set_res(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.res_ = value;
}

// -------------------------------------------------------------------

// EmptyRequest

// int32 handler = 1;
inline void EmptyRequest::clear_handler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.handler_ = 0;
}
inline ::int32_t EmptyRequest::handler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.EmptyRequest.handler)
  return _internal_handler();
}
inline void EmptyRequest::set_handler(::int32_t value) {
  _internal_set_handler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.EmptyRequest.handler)
}
inline ::int32_t EmptyRequest::_internal_handler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.handler_;
}
inline void EmptyRequest::_internal_set_handler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.handler_ = value;
}

// -------------------------------------------------------------------

// EmptyReply

// -------------------------------------------------------------------

// PolicyRequest

// int32 enforcerHandler = 1;
inline void PolicyRequest::clear_enforcerhandler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enforcerhandler_ = 0;
}
inline ::int32_t PolicyRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PolicyRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void PolicyRequest::set_enforcerhandler(::int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.PolicyRequest.enforcerHandler)
}
inline ::int32_t PolicyRequest::_internal_enforcerhandler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enforcerhandler_;
}
inline void PolicyRequest::_internal_set_enforcerhandler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enforcerhandler_ = value;
}

// string pType = 2;
inline void PolicyRequest::clear_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ptype_.ClearToEmpty();
}
inline const std::string& PolicyRequest::ptype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PolicyRequest.pType)
  return _internal_ptype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PolicyRequest::set_ptype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ptype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.PolicyRequest.pType)
}
inline std::string* PolicyRequest::mutable_ptype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ptype();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.PolicyRequest.pType)
  return _s;
}
inline const std::string& PolicyRequest::_internal_ptype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ptype_.Get();
}
inline void PolicyRequest::_internal_set_ptype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ptype_.Set(value, GetArena());
}
inline std::string* PolicyRequest::_internal_mutable_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ptype_.Mutable( GetArena());
}
inline std::string* PolicyRequest::release_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.PolicyRequest.pType)
  return _impl_.ptype_.Release();
}
inline void PolicyRequest::set_allocated_ptype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ptype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ptype_.IsDefault()) {
          _impl_.ptype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.PolicyRequest.pType)
}

// repeated string params = 3;
inline int PolicyRequest::_internal_params_size() const {
  return _internal_params().size();
}
inline int PolicyRequest::params_size() const {
  return _internal_params_size();
}
inline void PolicyRequest::clear_params() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.params_.Clear();
}
inline std::string* PolicyRequest::add_params()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_params()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.PolicyRequest.params)
  return _s;
}
inline const std::string& PolicyRequest::params(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PolicyRequest.params)
  return _internal_params().Get(index);
}
inline std::string* PolicyRequest::mutable_params(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.PolicyRequest.params)
  return _internal_mutable_params()->Mutable(index);
}
inline void PolicyRequest::set_params(int index, const std::string& value) {
  _internal_mutable_params()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, std::string&& value) {
  _internal_mutable_params()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_params()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_params()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::set_params(int index, absl::string_view value) {
  _internal_mutable_params()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.PolicyRequest.params)
}
inline void PolicyRequest::add_params(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_params()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.PolicyRequest.params)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PolicyRequest::params() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.PolicyRequest.params)
  return _internal_params();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PolicyRequest::mutable_params() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.PolicyRequest.params)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_params();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PolicyRequest::_internal_params() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.params_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PolicyRequest::_internal_mutable_params() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.params_;
}

// -------------------------------------------------------------------

// SimpleGetRequest

// int32 enforcerHandler = 1;
inline void SimpleGetRequest::clear_enforcerhandler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enforcerhandler_ = 0;
}
inline ::int32_t SimpleGetRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.SimpleGetRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void SimpleGetRequest::set_enforcerhandler(::int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.SimpleGetRequest.enforcerHandler)
}
inline ::int32_t SimpleGetRequest::_internal_enforcerhandler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enforcerhandler_;
}
inline void SimpleGetRequest::_internal_set_enforcerhandler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enforcerhandler_ = value;
}

// string pType = 2;
inline void SimpleGetRequest::clear_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ptype_.ClearToEmpty();
}
inline const std::string& SimpleGetRequest::ptype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.SimpleGetRequest.pType)
  return _internal_ptype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SimpleGetRequest::set_ptype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ptype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.SimpleGetRequest.pType)
}
inline std::string* SimpleGetRequest::mutable_ptype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ptype();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.SimpleGetRequest.pType)
  return _s;
}
inline const std::string& SimpleGetRequest::_internal_ptype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ptype_.Get();
}
inline void SimpleGetRequest::_internal_set_ptype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ptype_.Set(value, GetArena());
}
inline std::string* SimpleGetRequest::_internal_mutable_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ptype_.Mutable( GetArena());
}
inline std::string* SimpleGetRequest::release_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.SimpleGetRequest.pType)
  return _impl_.ptype_.Release();
}
inline void SimpleGetRequest::set_allocated_ptype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ptype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ptype_.IsDefault()) {
          _impl_.ptype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.SimpleGetRequest.pType)
}

// -------------------------------------------------------------------

// ArrayReply

// repeated string array = 1;
inline int ArrayReply::_internal_array_size() const {
  return _internal_array().size();
}
inline int ArrayReply::array_size() const {
  return _internal_array_size();
}
inline void ArrayReply::clear_array() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.array_.Clear();
}
inline std::string* ArrayReply::add_array()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_array()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.ArrayReply.array)
  return _s;
}
inline const std::string& ArrayReply::array(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.ArrayReply.array)
  return _internal_array().Get(index);
}
inline std::string* ArrayReply::mutable_array(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.ArrayReply.array)
  return _internal_mutable_array()->Mutable(index);
}
inline void ArrayReply::set_array(int index, const std::string& value) {
  _internal_mutable_array()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, std::string&& value) {
  _internal_mutable_array()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_array()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_array()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::set_array(int index, absl::string_view value) {
  _internal_mutable_array()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_array()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_array()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_array()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_array()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.ArrayReply.array)
}
inline void ArrayReply::add_array(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_array()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.ArrayReply.array)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ArrayReply::array() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.ArrayReply.array)
  return _internal_array();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ArrayReply::mutable_array() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.ArrayReply.array)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_array();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ArrayReply::_internal_array() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.array_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ArrayReply::_internal_mutable_array() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.array_;
}

// -------------------------------------------------------------------

// FilteredPolicyRequest

// int32 enforcerHandler = 1;
inline void FilteredPolicyRequest::clear_enforcerhandler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enforcerhandler_ = 0;
}
inline ::int32_t FilteredPolicyRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.FilteredPolicyRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void FilteredPolicyRequest::set_enforcerhandler(::int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.FilteredPolicyRequest.enforcerHandler)
}
inline ::int32_t FilteredPolicyRequest::_internal_enforcerhandler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enforcerhandler_;
}
inline void FilteredPolicyRequest::_internal_set_enforcerhandler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enforcerhandler_ = value;
}

// string pType = 2;
inline void FilteredPolicyRequest::clear_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ptype_.ClearToEmpty();
}
inline const std::string& FilteredPolicyRequest::ptype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.FilteredPolicyRequest.pType)
  return _internal_ptype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FilteredPolicyRequest::set_ptype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ptype_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.FilteredPolicyRequest.pType)
}
inline std::string* FilteredPolicyRequest::mutable_ptype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ptype();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.FilteredPolicyRequest.pType)
  return _s;
}
inline const std::string& FilteredPolicyRequest::_internal_ptype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ptype_.Get();
}
inline void FilteredPolicyRequest::_internal_set_ptype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ptype_.Set(value, GetArena());
}
inline std::string* FilteredPolicyRequest::_internal_mutable_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ptype_.Mutable( GetArena());
}
inline std::string* FilteredPolicyRequest::release_ptype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.FilteredPolicyRequest.pType)
  return _impl_.ptype_.Release();
}
inline void FilteredPolicyRequest::set_allocated_ptype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ptype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ptype_.IsDefault()) {
          _impl_.ptype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.FilteredPolicyRequest.pType)
}

// int32 fieldIndex = 3;
inline void FilteredPolicyRequest::clear_fieldindex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fieldindex_ = 0;
}
inline ::int32_t FilteredPolicyRequest::fieldindex() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.FilteredPolicyRequest.fieldIndex)
  return _internal_fieldindex();
}
inline void FilteredPolicyRequest::set_fieldindex(::int32_t value) {
  _internal_set_fieldindex(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.FilteredPolicyRequest.fieldIndex)
}
inline ::int32_t FilteredPolicyRequest::_internal_fieldindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fieldindex_;
}
inline void FilteredPolicyRequest::_internal_set_fieldindex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fieldindex_ = value;
}

// repeated string fieldValues = 4;
inline int FilteredPolicyRequest::_internal_fieldvalues_size() const {
  return _internal_fieldvalues().size();
}
inline int FilteredPolicyRequest::fieldvalues_size() const {
  return _internal_fieldvalues_size();
}
inline void FilteredPolicyRequest::clear_fieldvalues() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fieldvalues_.Clear();
}
inline std::string* FilteredPolicyRequest::add_fieldvalues()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_fieldvalues()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.FilteredPolicyRequest.fieldValues)
  return _s;
}
inline const std::string& FilteredPolicyRequest::fieldvalues(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.FilteredPolicyRequest.fieldValues)
  return _internal_fieldvalues().Get(index);
}
inline std::string* FilteredPolicyRequest::mutable_fieldvalues(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.FilteredPolicyRequest.fieldValues)
  return _internal_mutable_fieldvalues()->Mutable(index);
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, const std::string& value) {
  _internal_mutable_fieldvalues()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, std::string&& value) {
  _internal_mutable_fieldvalues()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_fieldvalues()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_fieldvalues()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::set_fieldvalues(int index, absl::string_view value) {
  _internal_mutable_fieldvalues()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fieldvalues()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fieldvalues()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fieldvalues()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fieldvalues()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline void FilteredPolicyRequest::add_fieldvalues(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_fieldvalues()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.FilteredPolicyRequest.fieldValues)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FilteredPolicyRequest::fieldvalues() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.FilteredPolicyRequest.fieldValues)
  return _internal_fieldvalues();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FilteredPolicyRequest::mutable_fieldvalues() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.FilteredPolicyRequest.fieldValues)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_fieldvalues();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
FilteredPolicyRequest::_internal_fieldvalues() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fieldvalues_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
FilteredPolicyRequest::_internal_mutable_fieldvalues() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.fieldvalues_;
}

// -------------------------------------------------------------------

// UserRoleRequest

// int32 enforcerHandler = 1;
inline void UserRoleRequest::clear_enforcerhandler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enforcerhandler_ = 0;
}
inline ::int32_t UserRoleRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.UserRoleRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void UserRoleRequest::set_enforcerhandler(::int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.UserRoleRequest.enforcerHandler)
}
inline ::int32_t UserRoleRequest::_internal_enforcerhandler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enforcerhandler_;
}
inline void UserRoleRequest::_internal_set_enforcerhandler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enforcerhandler_ = value;
}

// string user = 2;
inline void UserRoleRequest::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& UserRoleRequest::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.UserRoleRequest.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserRoleRequest::set_user(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.UserRoleRequest.user)
}
inline std::string* UserRoleRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.UserRoleRequest.user)
  return _s;
}
inline const std::string& UserRoleRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_.Get();
}
inline void UserRoleRequest::_internal_set_user(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(value, GetArena());
}
inline std::string* UserRoleRequest::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* UserRoleRequest::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.UserRoleRequest.user)
  return _impl_.user_.Release();
}
inline void UserRoleRequest::set_allocated_user(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.UserRoleRequest.user)
}

// string role = 3;
inline void UserRoleRequest::clear_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_.ClearToEmpty();
}
inline const std::string& UserRoleRequest::role() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.UserRoleRequest.role)
  return _internal_role();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserRoleRequest::set_role(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.role_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.UserRoleRequest.role)
}
inline std::string* UserRoleRequest::mutable_role() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.UserRoleRequest.role)
  return _s;
}
inline const std::string& UserRoleRequest::_internal_role() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.role_.Get();
}
inline void UserRoleRequest::_internal_set_role(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.role_.Set(value, GetArena());
}
inline std::string* UserRoleRequest::_internal_mutable_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.role_.Mutable( GetArena());
}
inline std::string* UserRoleRequest::release_role() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.UserRoleRequest.role)
  return _impl_.role_.Release();
}
inline void UserRoleRequest::set_allocated_role(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.role_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.role_.IsDefault()) {
          _impl_.role_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.UserRoleRequest.role)
}

// repeated string domain = 4;
inline int UserRoleRequest::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int UserRoleRequest::domain_size() const {
  return _internal_domain_size();
}
inline void UserRoleRequest::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.Clear();
}
inline std::string* UserRoleRequest::add_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_domain()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.UserRoleRequest.domain)
  return _s;
}
inline const std::string& UserRoleRequest::domain(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.UserRoleRequest.domain)
  return _internal_domain().Get(index);
}
inline std::string* UserRoleRequest::mutable_domain(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.UserRoleRequest.domain)
  return _internal_mutable_domain()->Mutable(index);
}
inline void UserRoleRequest::set_domain(int index, const std::string& value) {
  _internal_mutable_domain()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, std::string&& value) {
  _internal_mutable_domain()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_domain()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_domain()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::set_domain(int index, absl::string_view value) {
  _internal_mutable_domain()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.UserRoleRequest.domain)
}
inline void UserRoleRequest::add_domain(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.UserRoleRequest.domain)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserRoleRequest::domain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.UserRoleRequest.domain)
  return _internal_domain();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserRoleRequest::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.UserRoleRequest.domain)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_domain();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UserRoleRequest::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UserRoleRequest::_internal_mutable_domain() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// PermissionRequest

// int32 enforcerHandler = 1;
inline void PermissionRequest::clear_enforcerhandler() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.enforcerhandler_ = 0;
}
inline ::int32_t PermissionRequest::enforcerhandler() const {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PermissionRequest.enforcerHandler)
  return _internal_enforcerhandler();
}
inline void PermissionRequest::set_enforcerhandler(::int32_t value) {
  _internal_set_enforcerhandler(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.PermissionRequest.enforcerHandler)
}
inline ::int32_t PermissionRequest::_internal_enforcerhandler() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.enforcerhandler_;
}
inline void PermissionRequest::_internal_set_enforcerhandler(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.enforcerhandler_ = value;
}

// string user = 2;
inline void PermissionRequest::clear_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.ClearToEmpty();
}
inline const std::string& PermissionRequest::user() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PermissionRequest.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PermissionRequest::set_user(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:palm.lily.v1.PermissionRequest.user)
}
inline std::string* PermissionRequest::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.PermissionRequest.user)
  return _s;
}
inline const std::string& PermissionRequest::_internal_user() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_.Get();
}
inline void PermissionRequest::_internal_set_user(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.user_.Set(value, GetArena());
}
inline std::string* PermissionRequest::_internal_mutable_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.user_.Mutable( GetArena());
}
inline std::string* PermissionRequest::release_user() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:palm.lily.v1.PermissionRequest.user)
  return _impl_.user_.Release();
}
inline void PermissionRequest::set_allocated_user(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.lily.v1.PermissionRequest.user)
}

// repeated string permissions = 3;
inline int PermissionRequest::_internal_permissions_size() const {
  return _internal_permissions().size();
}
inline int PermissionRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void PermissionRequest::clear_permissions() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permissions_.Clear();
}
inline std::string* PermissionRequest::add_permissions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_permissions()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.PermissionRequest.permissions)
  return _s;
}
inline const std::string& PermissionRequest::permissions(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PermissionRequest.permissions)
  return _internal_permissions().Get(index);
}
inline std::string* PermissionRequest::mutable_permissions(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.PermissionRequest.permissions)
  return _internal_mutable_permissions()->Mutable(index);
}
inline void PermissionRequest::set_permissions(int index, const std::string& value) {
  _internal_mutable_permissions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, std::string&& value) {
  _internal_mutable_permissions()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_permissions()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_permissions()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::set_permissions(int index, absl::string_view value) {
  _internal_mutable_permissions()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_permissions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_permissions()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_permissions()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_permissions()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.PermissionRequest.permissions)
}
inline void PermissionRequest::add_permissions(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_permissions()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.PermissionRequest.permissions)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PermissionRequest::permissions() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.PermissionRequest.permissions)
  return _internal_permissions();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PermissionRequest::mutable_permissions() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.PermissionRequest.permissions)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_permissions();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PermissionRequest::_internal_permissions() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permissions_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PermissionRequest::_internal_mutable_permissions() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.permissions_;
}

// repeated string domain = 4;
inline int PermissionRequest::_internal_domain_size() const {
  return _internal_domain().size();
}
inline int PermissionRequest::domain_size() const {
  return _internal_domain_size();
}
inline void PermissionRequest::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.Clear();
}
inline std::string* PermissionRequest::add_domain()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_domain()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.PermissionRequest.domain)
  return _s;
}
inline const std::string& PermissionRequest::domain(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.PermissionRequest.domain)
  return _internal_domain().Get(index);
}
inline std::string* PermissionRequest::mutable_domain(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.PermissionRequest.domain)
  return _internal_mutable_domain()->Mutable(index);
}
inline void PermissionRequest::set_domain(int index, const std::string& value) {
  _internal_mutable_domain()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, std::string&& value) {
  _internal_mutable_domain()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_domain()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_domain()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::set_domain(int index, absl::string_view value) {
  _internal_mutable_domain()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.PermissionRequest.domain)
}
inline void PermissionRequest::add_domain(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_domain()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.PermissionRequest.domain)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PermissionRequest::domain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.PermissionRequest.domain)
  return _internal_domain();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PermissionRequest::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.PermissionRequest.domain)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_domain();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PermissionRequest::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PermissionRequest::_internal_mutable_domain() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.domain_;
}

// -------------------------------------------------------------------

// Array2DReply_d

// repeated string d1 = 1;
inline int Array2DReply_d::_internal_d1_size() const {
  return _internal_d1().size();
}
inline int Array2DReply_d::d1_size() const {
  return _internal_d1_size();
}
inline void Array2DReply_d::clear_d1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.d1_.Clear();
}
inline std::string* Array2DReply_d::add_d1()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_d1()->Add();
  // @@protoc_insertion_point(field_add_mutable:palm.lily.v1.Array2DReply.d.d1)
  return _s;
}
inline const std::string& Array2DReply_d::d1(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.Array2DReply.d.d1)
  return _internal_d1().Get(index);
}
inline std::string* Array2DReply_d::mutable_d1(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.Array2DReply.d.d1)
  return _internal_mutable_d1()->Mutable(index);
}
inline void Array2DReply_d::set_d1(int index, const std::string& value) {
  _internal_mutable_d1()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, std::string&& value) {
  _internal_mutable_d1()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_d1()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_d1()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::set_d1(int index, absl::string_view value) {
  _internal_mutable_d1()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_d1()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_d1()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_d1()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_d1()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:palm.lily.v1.Array2DReply.d.d1)
}
inline void Array2DReply_d::add_d1(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_d1()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:palm.lily.v1.Array2DReply.d.d1)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Array2DReply_d::d1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.Array2DReply.d.d1)
  return _internal_d1();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Array2DReply_d::mutable_d1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.Array2DReply.d.d1)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_d1();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Array2DReply_d::_internal_d1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.d1_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Array2DReply_d::_internal_mutable_d1() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.d1_;
}

// -------------------------------------------------------------------

// Array2DReply

// repeated .palm.lily.v1.Array2DReply.d d2 = 1;
inline int Array2DReply::_internal_d2_size() const {
  return _internal_d2().size();
}
inline int Array2DReply::d2_size() const {
  return _internal_d2_size();
}
inline void Array2DReply::clear_d2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.d2_.Clear();
}
inline ::palm::lily::v1::Array2DReply_d* Array2DReply::mutable_d2(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:palm.lily.v1.Array2DReply.d2)
  return _internal_mutable_d2()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::palm::lily::v1::Array2DReply_d>* Array2DReply::mutable_d2()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:palm.lily.v1.Array2DReply.d2)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_d2();
}
inline const ::palm::lily::v1::Array2DReply_d& Array2DReply::d2(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:palm.lily.v1.Array2DReply.d2)
  return _internal_d2().Get(index);
}
inline ::palm::lily::v1::Array2DReply_d* Array2DReply::add_d2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::palm::lily::v1::Array2DReply_d* _add = _internal_mutable_d2()->Add();
  // @@protoc_insertion_point(field_add:palm.lily.v1.Array2DReply.d2)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::palm::lily::v1::Array2DReply_d>& Array2DReply::d2() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:palm.lily.v1.Array2DReply.d2)
  return _internal_d2();
}
inline const ::google::protobuf::RepeatedPtrField<::palm::lily::v1::Array2DReply_d>&
Array2DReply::_internal_d2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.d2_;
}
inline ::google::protobuf::RepeatedPtrField<::palm::lily::v1::Array2DReply_d>*
Array2DReply::_internal_mutable_d2() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.d2_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace lily
}  // namespace palm


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_casbin_2eproto_2epb_2eh
