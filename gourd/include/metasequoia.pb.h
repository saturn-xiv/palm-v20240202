// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metasequoia.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_metasequoia_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_metasequoia_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_metasequoia_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_metasequoia_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_metasequoia_2eproto;
namespace palm {
namespace metasequoia {
namespace v1 {
class Permission;
struct PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class RbacCanRequest;
struct RbacCanRequestDefaultTypeInternal;
extern RbacCanRequestDefaultTypeInternal _RbacCanRequest_default_instance_;
class RbacHasRequest;
struct RbacHasRequestDefaultTypeInternal;
extern RbacHasRequestDefaultTypeInternal _RbacHasRequest_default_instance_;
class RbacPermissionItem;
struct RbacPermissionItemDefaultTypeInternal;
extern RbacPermissionItemDefaultTypeInternal _RbacPermissionItem_default_instance_;
class RbacPermissionsForRoleRequest;
struct RbacPermissionsForRoleRequestDefaultTypeInternal;
extern RbacPermissionsForRoleRequestDefaultTypeInternal _RbacPermissionsForRoleRequest_default_instance_;
class RbacPermissionsForUserRequest;
struct RbacPermissionsForUserRequestDefaultTypeInternal;
extern RbacPermissionsForUserRequestDefaultTypeInternal _RbacPermissionsForUserRequest_default_instance_;
class RbacPermissionsResponse;
struct RbacPermissionsResponseDefaultTypeInternal;
extern RbacPermissionsResponseDefaultTypeInternal _RbacPermissionsResponse_default_instance_;
class RbacRolesForUserRequest;
struct RbacRolesForUserRequestDefaultTypeInternal;
extern RbacRolesForUserRequestDefaultTypeInternal _RbacRolesForUserRequest_default_instance_;
class RbacRolesResponse;
struct RbacRolesResponseDefaultTypeInternal;
extern RbacRolesResponseDefaultTypeInternal _RbacRolesResponse_default_instance_;
class RbacUsersResponse;
struct RbacUsersResponseDefaultTypeInternal;
extern RbacUsersResponseDefaultTypeInternal _RbacUsersResponse_default_instance_;
class Resource;
struct ResourceDefaultTypeInternal;
extern ResourceDefaultTypeInternal _Resource_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace v1
}  // namespace metasequoia
}  // namespace palm
PROTOBUF_NAMESPACE_OPEN
template<> ::palm::metasequoia::v1::Permission* Arena::CreateMaybeMessage<::palm::metasequoia::v1::Permission>(Arena*);
template<> ::palm::metasequoia::v1::RbacCanRequest* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacCanRequest>(Arena*);
template<> ::palm::metasequoia::v1::RbacHasRequest* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacHasRequest>(Arena*);
template<> ::palm::metasequoia::v1::RbacPermissionItem* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacPermissionItem>(Arena*);
template<> ::palm::metasequoia::v1::RbacPermissionsForRoleRequest* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacPermissionsForRoleRequest>(Arena*);
template<> ::palm::metasequoia::v1::RbacPermissionsForUserRequest* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacPermissionsForUserRequest>(Arena*);
template<> ::palm::metasequoia::v1::RbacPermissionsResponse* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacPermissionsResponse>(Arena*);
template<> ::palm::metasequoia::v1::RbacRolesForUserRequest* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacRolesForUserRequest>(Arena*);
template<> ::palm::metasequoia::v1::RbacRolesResponse* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacRolesResponse>(Arena*);
template<> ::palm::metasequoia::v1::RbacUsersResponse* Arena::CreateMaybeMessage<::palm::metasequoia::v1::RbacUsersResponse>(Arena*);
template<> ::palm::metasequoia::v1::Resource* Arena::CreateMaybeMessage<::palm::metasequoia::v1::Resource>(Arena*);
template<> ::palm::metasequoia::v1::Role* Arena::CreateMaybeMessage<::palm::metasequoia::v1::Role>(Arena*);
template<> ::palm::metasequoia::v1::User* Arena::CreateMaybeMessage<::palm::metasequoia::v1::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace palm {
namespace metasequoia {
namespace v1 {

// ===================================================================

class Permission final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Permission) */ {
 public:
  inline Permission() : Permission(nullptr) {}
  ~Permission() override;
  explicit PROTOBUF_CONSTEXPR Permission(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Permission& default_instance() {
    return *internal_default_instance();
  }
  enum SubjectCase {
    kUser = 1,
    kRole = 2,
    SUBJECT_NOT_SET = 0,
  };

  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Permission* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Permission& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Permission& from) {
    Permission::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.Permission";
  }
  protected:
  explicit Permission(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 12,
    kObjectFieldNumber = 11,
    kUserFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string action = 12;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // .palm.metasequoia.v1.Resource object = 11;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::palm::metasequoia::v1::Resource& object() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Resource* release_object();
  ::palm::metasequoia::v1::Resource* mutable_object();
  void set_allocated_object(::palm::metasequoia::v1::Resource* object);
  private:
  const ::palm::metasequoia::v1::Resource& _internal_object() const;
  ::palm::metasequoia::v1::Resource* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::palm::metasequoia::v1::Resource* object);
  ::palm::metasequoia::v1::Resource* unsafe_arena_release_object();

  // int32 user = 1;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  int32_t user() const;
  void set_user(int32_t value);
  private:
  int32_t _internal_user() const;
  void _internal_set_user(int32_t value);
  public:

  // .palm.metasequoia.v1.Role role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::palm::metasequoia::v1::Role& role() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role* release_role();
  ::palm::metasequoia::v1::Role* mutable_role();
  void set_allocated_role(::palm::metasequoia::v1::Role* role);
  private:
  const ::palm::metasequoia::v1::Role& _internal_role() const;
  ::palm::metasequoia::v1::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::palm::metasequoia::v1::Role* role);
  ::palm::metasequoia::v1::Role* unsafe_arena_release_role();

  void clear_subject();
  SubjectCase subject_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Permission)
 private:
  class _Internal;
  void set_has_user();
  void set_has_role();

  inline bool has_subject() const;
  inline void clear_has_subject();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::palm::metasequoia::v1::Resource* object_;
    union SubjectUnion {
      constexpr SubjectUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t user_;
      ::palm::metasequoia::v1::Role* role_;
    } subject_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class Resource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Resource) */ {
 public:
  inline Resource() : Resource(nullptr) {}
  ~Resource() override;
  explicit PROTOBUF_CONSTEXPR Resource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Resource(const Resource& from);
  Resource(Resource&& from) noexcept
    : Resource() {
    *this = ::std::move(from);
  }

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  inline Resource& operator=(Resource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Resource& default_instance() {
    return *internal_default_instance();
  }
  enum IdCase {
    kS = 1,
    kI = 2,
    ID_NOT_SET = 0,
  };

  static inline const Resource* internal_default_instance() {
    return reinterpret_cast<const Resource*>(
               &_Resource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Resource& a, Resource& b) {
    a.Swap(&b);
  }
  inline void Swap(Resource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Resource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Resource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Resource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Resource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Resource& from) {
    Resource::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Resource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.Resource";
  }
  protected:
  explicit Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 11,
    kSFieldNumber = 1,
    kIFieldNumber = 2,
  };
  // string type = 11;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string s = 1;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // int32 i = 2;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int32_t i() const;
  void set_i(int32_t value);
  private:
  int32_t _internal_i() const;
  void _internal_set_i(int32_t value);
  public:

  void clear_id();
  IdCase id_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Resource)
 private:
  class _Internal;
  void set_has_s();
  void set_has_i();

  inline bool has_id() const;
  inline void clear_has_id();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    union IdUnion {
      constexpr IdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
      int32_t i_;
    } id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class Role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() override;
  explicit PROTOBUF_CONSTEXPR Role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Role(const Role& from);
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  enum ByCase {
    kAdministrator = 1,
    kRoot = 2,
    kCode = 3,
    BY_NOT_SET = 0,
  };

  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }
  inline void Swap(Role* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Role& from) {
    Role::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.Role";
  }
  protected:
  explicit Role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdministratorFieldNumber = 1,
    kRootFieldNumber = 2,
    kCodeFieldNumber = 3,
  };
  // .google.protobuf.Empty administrator = 1;
  bool has_administrator() const;
  private:
  bool _internal_has_administrator() const;
  public:
  void clear_administrator();
  const ::PROTOBUF_NAMESPACE_ID::Empty& administrator() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_administrator();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_administrator();
  void set_allocated_administrator(::PROTOBUF_NAMESPACE_ID::Empty* administrator);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_administrator() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_administrator();
  public:
  void unsafe_arena_set_allocated_administrator(
      ::PROTOBUF_NAMESPACE_ID::Empty* administrator);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_administrator();

  // .google.protobuf.Empty root = 2;
  bool has_root() const;
  private:
  bool _internal_has_root() const;
  public:
  void clear_root();
  const ::PROTOBUF_NAMESPACE_ID::Empty& root() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Empty* release_root();
  ::PROTOBUF_NAMESPACE_ID::Empty* mutable_root();
  void set_allocated_root(::PROTOBUF_NAMESPACE_ID::Empty* root);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Empty& _internal_root() const;
  ::PROTOBUF_NAMESPACE_ID::Empty* _internal_mutable_root();
  public:
  void unsafe_arena_set_allocated_root(
      ::PROTOBUF_NAMESPACE_ID::Empty* root);
  ::PROTOBUF_NAMESPACE_ID::Empty* unsafe_arena_release_root();

  // string code = 3;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  void clear_by();
  ByCase by_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.Role)
 private:
  class _Internal;
  void set_has_administrator();
  void set_has_root();
  void set_has_code();

  inline bool has_by() const;
  inline void clear_has_by();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ByUnion {
      constexpr ByUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::Empty* administrator_;
      ::PROTOBUF_NAMESPACE_ID::Empty* root_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    } by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  enum ByCase {
    kId = 1,
    kCode = 2,
    BY_NOT_SET = 0,
  };

  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // string code = 2;
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  void clear_by();
  ByCase by_case() const;
  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.User)
 private:
  class _Internal;
  void set_has_id();
  void set_has_code();

  inline bool has_by() const;
  inline void clear_has_by();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ByUnion {
      constexpr ByUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int32_t id_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
    } by_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacCanRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacCanRequest) */ {
 public:
  inline RbacCanRequest() : RbacCanRequest(nullptr) {}
  ~RbacCanRequest() override;
  explicit PROTOBUF_CONSTEXPR RbacCanRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacCanRequest(const RbacCanRequest& from);
  RbacCanRequest(RbacCanRequest&& from) noexcept
    : RbacCanRequest() {
    *this = ::std::move(from);
  }

  inline RbacCanRequest& operator=(const RbacCanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacCanRequest& operator=(RbacCanRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacCanRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacCanRequest* internal_default_instance() {
    return reinterpret_cast<const RbacCanRequest*>(
               &_RbacCanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RbacCanRequest& a, RbacCanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacCanRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacCanRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacCanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacCanRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacCanRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacCanRequest& from) {
    RbacCanRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacCanRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacCanRequest";
  }
  protected:
  explicit RbacCanRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 3,
    kObjectFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // string action = 3;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // .palm.metasequoia.v1.Resource object = 2;
  bool has_object() const;
  private:
  bool _internal_has_object() const;
  public:
  void clear_object();
  const ::palm::metasequoia::v1::Resource& object() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Resource* release_object();
  ::palm::metasequoia::v1::Resource* mutable_object();
  void set_allocated_object(::palm::metasequoia::v1::Resource* object);
  private:
  const ::palm::metasequoia::v1::Resource& _internal_object() const;
  ::palm::metasequoia::v1::Resource* _internal_mutable_object();
  public:
  void unsafe_arena_set_allocated_object(
      ::palm::metasequoia::v1::Resource* object);
  ::palm::metasequoia::v1::Resource* unsafe_arena_release_object();

  // int32 user = 1;
  void clear_user();
  int32_t user() const;
  void set_user(int32_t value);
  private:
  int32_t _internal_user() const;
  void _internal_set_user(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacCanRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::palm::metasequoia::v1::Resource* object_;
    int32_t user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacHasRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacHasRequest) */ {
 public:
  inline RbacHasRequest() : RbacHasRequest(nullptr) {}
  ~RbacHasRequest() override;
  explicit PROTOBUF_CONSTEXPR RbacHasRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacHasRequest(const RbacHasRequest& from);
  RbacHasRequest(RbacHasRequest&& from) noexcept
    : RbacHasRequest() {
    *this = ::std::move(from);
  }

  inline RbacHasRequest& operator=(const RbacHasRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacHasRequest& operator=(RbacHasRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacHasRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacHasRequest* internal_default_instance() {
    return reinterpret_cast<const RbacHasRequest*>(
               &_RbacHasRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RbacHasRequest& a, RbacHasRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacHasRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacHasRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacHasRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacHasRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacHasRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacHasRequest& from) {
    RbacHasRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacHasRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacHasRequest";
  }
  protected:
  explicit RbacHasRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // .palm.metasequoia.v1.Role role = 2;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::palm::metasequoia::v1::Role& role() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role* release_role();
  ::palm::metasequoia::v1::Role* mutable_role();
  void set_allocated_role(::palm::metasequoia::v1::Role* role);
  private:
  const ::palm::metasequoia::v1::Role& _internal_role() const;
  ::palm::metasequoia::v1::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::palm::metasequoia::v1::Role* role);
  ::palm::metasequoia::v1::Role* unsafe_arena_release_role();

  // int32 user = 1;
  void clear_user();
  int32_t user() const;
  void set_user(int32_t value);
  private:
  int32_t _internal_user() const;
  void _internal_set_user(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacHasRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::palm::metasequoia::v1::Role* role_;
    int32_t user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacPermissionItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionItem) */ {
 public:
  inline RbacPermissionItem() : RbacPermissionItem(nullptr) {}
  ~RbacPermissionItem() override;
  explicit PROTOBUF_CONSTEXPR RbacPermissionItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacPermissionItem(const RbacPermissionItem& from);
  RbacPermissionItem(RbacPermissionItem&& from) noexcept
    : RbacPermissionItem() {
    *this = ::std::move(from);
  }

  inline RbacPermissionItem& operator=(const RbacPermissionItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionItem& operator=(RbacPermissionItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionItem* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionItem*>(
               &_RbacPermissionItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RbacPermissionItem& a, RbacPermissionItem& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacPermissionItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacPermissionItem& from) {
    RbacPermissionItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionItem";
  }
  protected:
  explicit RbacPermissionItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // string action = 1;
  void clear_action();
  const std::string& action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action();
  PROTOBUF_NODISCARD std::string* release_action();
  void set_allocated_action(std::string* action);
  private:
  const std::string& _internal_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action(const std::string& value);
  std::string* _internal_mutable_action();
  public:

  // .palm.metasequoia.v1.Resource resource = 2;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::palm::metasequoia::v1::Resource& resource() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Resource* release_resource();
  ::palm::metasequoia::v1::Resource* mutable_resource();
  void set_allocated_resource(::palm::metasequoia::v1::Resource* resource);
  private:
  const ::palm::metasequoia::v1::Resource& _internal_resource() const;
  ::palm::metasequoia::v1::Resource* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::palm::metasequoia::v1::Resource* resource);
  ::palm::metasequoia::v1::Resource* unsafe_arena_release_resource();

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_;
    ::palm::metasequoia::v1::Resource* resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacPermissionsForUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionsForUserRequest) */ {
 public:
  inline RbacPermissionsForUserRequest() : RbacPermissionsForUserRequest(nullptr) {}
  ~RbacPermissionsForUserRequest() override;
  explicit PROTOBUF_CONSTEXPR RbacPermissionsForUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacPermissionsForUserRequest(const RbacPermissionsForUserRequest& from);
  RbacPermissionsForUserRequest(RbacPermissionsForUserRequest&& from) noexcept
    : RbacPermissionsForUserRequest() {
    *this = ::std::move(from);
  }

  inline RbacPermissionsForUserRequest& operator=(const RbacPermissionsForUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionsForUserRequest& operator=(RbacPermissionsForUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionsForUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionsForUserRequest* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionsForUserRequest*>(
               &_RbacPermissionsForUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RbacPermissionsForUserRequest& a, RbacPermissionsForUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionsForUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionsForUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionsForUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionsForUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacPermissionsForUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacPermissionsForUserRequest& from) {
    RbacPermissionsForUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionsForUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionsForUserRequest";
  }
  protected:
  explicit RbacPermissionsForUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::palm::metasequoia::v1::RbacPermissionItem* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
      mutable_permissions();
  private:
  const ::palm::metasequoia::v1::RbacPermissionItem& _internal_permissions(int index) const;
  ::palm::metasequoia::v1::RbacPermissionItem* _internal_add_permissions();
  public:
  const ::palm::metasequoia::v1::RbacPermissionItem& permissions(int index) const;
  ::palm::metasequoia::v1::RbacPermissionItem* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
      permissions() const;

  // int32 user = 1;
  void clear_user();
  int32_t user() const;
  void set_user(int32_t value);
  private:
  int32_t _internal_user() const;
  void _internal_set_user(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionsForUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem > permissions_;
    int32_t user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacPermissionsForRoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionsForRoleRequest) */ {
 public:
  inline RbacPermissionsForRoleRequest() : RbacPermissionsForRoleRequest(nullptr) {}
  ~RbacPermissionsForRoleRequest() override;
  explicit PROTOBUF_CONSTEXPR RbacPermissionsForRoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacPermissionsForRoleRequest(const RbacPermissionsForRoleRequest& from);
  RbacPermissionsForRoleRequest(RbacPermissionsForRoleRequest&& from) noexcept
    : RbacPermissionsForRoleRequest() {
    *this = ::std::move(from);
  }

  inline RbacPermissionsForRoleRequest& operator=(const RbacPermissionsForRoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionsForRoleRequest& operator=(RbacPermissionsForRoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionsForRoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionsForRoleRequest* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionsForRoleRequest*>(
               &_RbacPermissionsForRoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RbacPermissionsForRoleRequest& a, RbacPermissionsForRoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionsForRoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionsForRoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionsForRoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionsForRoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacPermissionsForRoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacPermissionsForRoleRequest& from) {
    RbacPermissionsForRoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionsForRoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionsForRoleRequest";
  }
  protected:
  explicit RbacPermissionsForRoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kRoleFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  ::palm::metasequoia::v1::RbacPermissionItem* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
      mutable_permissions();
  private:
  const ::palm::metasequoia::v1::RbacPermissionItem& _internal_permissions(int index) const;
  ::palm::metasequoia::v1::RbacPermissionItem* _internal_add_permissions();
  public:
  const ::palm::metasequoia::v1::RbacPermissionItem& permissions(int index) const;
  ::palm::metasequoia::v1::RbacPermissionItem* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
      permissions() const;

  // .palm.metasequoia.v1.Role role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::palm::metasequoia::v1::Role& role() const;
  PROTOBUF_NODISCARD ::palm::metasequoia::v1::Role* release_role();
  ::palm::metasequoia::v1::Role* mutable_role();
  void set_allocated_role(::palm::metasequoia::v1::Role* role);
  private:
  const ::palm::metasequoia::v1::Role& _internal_role() const;
  ::palm::metasequoia::v1::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::palm::metasequoia::v1::Role* role);
  ::palm::metasequoia::v1::Role* unsafe_arena_release_role();

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionsForRoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem > permissions_;
    ::palm::metasequoia::v1::Role* role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacRolesForUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacRolesForUserRequest) */ {
 public:
  inline RbacRolesForUserRequest() : RbacRolesForUserRequest(nullptr) {}
  ~RbacRolesForUserRequest() override;
  explicit PROTOBUF_CONSTEXPR RbacRolesForUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacRolesForUserRequest(const RbacRolesForUserRequest& from);
  RbacRolesForUserRequest(RbacRolesForUserRequest&& from) noexcept
    : RbacRolesForUserRequest() {
    *this = ::std::move(from);
  }

  inline RbacRolesForUserRequest& operator=(const RbacRolesForUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacRolesForUserRequest& operator=(RbacRolesForUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacRolesForUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacRolesForUserRequest* internal_default_instance() {
    return reinterpret_cast<const RbacRolesForUserRequest*>(
               &_RbacRolesForUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RbacRolesForUserRequest& a, RbacRolesForUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacRolesForUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacRolesForUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacRolesForUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacRolesForUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacRolesForUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacRolesForUserRequest& from) {
    RbacRolesForUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacRolesForUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacRolesForUserRequest";
  }
  protected:
  explicit RbacRolesForUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.Role roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::palm::metasequoia::v1::Role* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
      mutable_roles();
  private:
  const ::palm::metasequoia::v1::Role& _internal_roles(int index) const;
  ::palm::metasequoia::v1::Role* _internal_add_roles();
  public:
  const ::palm::metasequoia::v1::Role& roles(int index) const;
  ::palm::metasequoia::v1::Role* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
      roles() const;

  // int32 user = 1;
  void clear_user();
  int32_t user() const;
  void set_user(int32_t value);
  private:
  int32_t _internal_user() const;
  void _internal_set_user(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacRolesForUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role > roles_;
    int32_t user_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacRolesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacRolesResponse) */ {
 public:
  inline RbacRolesResponse() : RbacRolesResponse(nullptr) {}
  ~RbacRolesResponse() override;
  explicit PROTOBUF_CONSTEXPR RbacRolesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacRolesResponse(const RbacRolesResponse& from);
  RbacRolesResponse(RbacRolesResponse&& from) noexcept
    : RbacRolesResponse() {
    *this = ::std::move(from);
  }

  inline RbacRolesResponse& operator=(const RbacRolesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacRolesResponse& operator=(RbacRolesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacRolesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacRolesResponse* internal_default_instance() {
    return reinterpret_cast<const RbacRolesResponse*>(
               &_RbacRolesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RbacRolesResponse& a, RbacRolesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacRolesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacRolesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacRolesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacRolesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacRolesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacRolesResponse& from) {
    RbacRolesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacRolesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacRolesResponse";
  }
  protected:
  explicit RbacRolesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.Role items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::metasequoia::v1::Role* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
      mutable_items();
  private:
  const ::palm::metasequoia::v1::Role& _internal_items(int index) const;
  ::palm::metasequoia::v1::Role* _internal_add_items();
  public:
  const ::palm::metasequoia::v1::Role& items(int index) const;
  ::palm::metasequoia::v1::Role* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
      items() const;

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacRolesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacPermissionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacPermissionsResponse) */ {
 public:
  inline RbacPermissionsResponse() : RbacPermissionsResponse(nullptr) {}
  ~RbacPermissionsResponse() override;
  explicit PROTOBUF_CONSTEXPR RbacPermissionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacPermissionsResponse(const RbacPermissionsResponse& from);
  RbacPermissionsResponse(RbacPermissionsResponse&& from) noexcept
    : RbacPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline RbacPermissionsResponse& operator=(const RbacPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacPermissionsResponse& operator=(RbacPermissionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacPermissionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const RbacPermissionsResponse*>(
               &_RbacPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RbacPermissionsResponse& a, RbacPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacPermissionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacPermissionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacPermissionsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacPermissionsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacPermissionsResponse& from) {
    RbacPermissionsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacPermissionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacPermissionsResponse";
  }
  protected:
  explicit RbacPermissionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.Permission items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::metasequoia::v1::Permission* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Permission >*
      mutable_items();
  private:
  const ::palm::metasequoia::v1::Permission& _internal_items(int index) const;
  ::palm::metasequoia::v1::Permission* _internal_add_items();
  public:
  const ::palm::metasequoia::v1::Permission& items(int index) const;
  ::palm::metasequoia::v1::Permission* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Permission >&
      items() const;

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacPermissionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Permission > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// -------------------------------------------------------------------

class RbacUsersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:palm.metasequoia.v1.RbacUsersResponse) */ {
 public:
  inline RbacUsersResponse() : RbacUsersResponse(nullptr) {}
  ~RbacUsersResponse() override;
  explicit PROTOBUF_CONSTEXPR RbacUsersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RbacUsersResponse(const RbacUsersResponse& from);
  RbacUsersResponse(RbacUsersResponse&& from) noexcept
    : RbacUsersResponse() {
    *this = ::std::move(from);
  }

  inline RbacUsersResponse& operator=(const RbacUsersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RbacUsersResponse& operator=(RbacUsersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RbacUsersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RbacUsersResponse* internal_default_instance() {
    return reinterpret_cast<const RbacUsersResponse*>(
               &_RbacUsersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RbacUsersResponse& a, RbacUsersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RbacUsersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RbacUsersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RbacUsersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RbacUsersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RbacUsersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RbacUsersResponse& from) {
    RbacUsersResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RbacUsersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "palm.metasequoia.v1.RbacUsersResponse";
  }
  protected:
  explicit RbacUsersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .palm.metasequoia.v1.User items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::palm::metasequoia::v1::User* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::User >*
      mutable_items();
  private:
  const ::palm::metasequoia::v1::User& _internal_items(int index) const;
  ::palm::metasequoia::v1::User* _internal_add_items();
  public:
  const ::palm::metasequoia::v1::User& items(int index) const;
  ::palm::metasequoia::v1::User* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::User >&
      items() const;

  // @@protoc_insertion_point(class_scope:palm.metasequoia.v1.RbacUsersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::User > items_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_metasequoia_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Permission

// int32 user = 1;
inline bool Permission::_internal_has_user() const {
  return subject_case() == kUser;
}
inline bool Permission::has_user() const {
  return _internal_has_user();
}
inline void Permission::set_has_user() {
  _impl_._oneof_case_[0] = kUser;
}
inline void Permission::clear_user() {
  if (_internal_has_user()) {
    _impl_.subject_.user_ = 0;
    clear_has_subject();
  }
}
inline int32_t Permission::_internal_user() const {
  if (_internal_has_user()) {
    return _impl_.subject_.user_;
  }
  return 0;
}
inline void Permission::_internal_set_user(int32_t value) {
  if (!_internal_has_user()) {
    clear_subject();
    set_has_user();
  }
  _impl_.subject_.user_ = value;
}
inline int32_t Permission::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.user)
  return _internal_user();
}
inline void Permission::set_user(int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Permission.user)
}

// .palm.metasequoia.v1.Role role = 2;
inline bool Permission::_internal_has_role() const {
  return subject_case() == kRole;
}
inline bool Permission::has_role() const {
  return _internal_has_role();
}
inline void Permission::set_has_role() {
  _impl_._oneof_case_[0] = kRole;
}
inline void Permission::clear_role() {
  if (_internal_has_role()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.subject_.role_;
    }
    clear_has_subject();
  }
}
inline ::palm::metasequoia::v1::Role* Permission::release_role() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Permission.role)
  if (_internal_has_role()) {
    clear_has_subject();
    ::palm::metasequoia::v1::Role* temp = _impl_.subject_.role_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subject_.role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::palm::metasequoia::v1::Role& Permission::_internal_role() const {
  return _internal_has_role()
      ? *_impl_.subject_.role_
      : reinterpret_cast< ::palm::metasequoia::v1::Role&>(::palm::metasequoia::v1::_Role_default_instance_);
}
inline const ::palm::metasequoia::v1::Role& Permission::role() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.role)
  return _internal_role();
}
inline ::palm::metasequoia::v1::Role* Permission::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Permission.role)
  if (_internal_has_role()) {
    clear_has_subject();
    ::palm::metasequoia::v1::Role* temp = _impl_.subject_.role_;
    _impl_.subject_.role_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Permission::unsafe_arena_set_allocated_role(::palm::metasequoia::v1::Role* role) {
  clear_subject();
  if (role) {
    set_has_role();
    _impl_.subject_.role_ = role;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Permission.role)
}
inline ::palm::metasequoia::v1::Role* Permission::_internal_mutable_role() {
  if (!_internal_has_role()) {
    clear_subject();
    set_has_role();
    _impl_.subject_.role_ = CreateMaybeMessage< ::palm::metasequoia::v1::Role >(GetArenaForAllocation());
  }
  return _impl_.subject_.role_;
}
inline ::palm::metasequoia::v1::Role* Permission::mutable_role() {
  ::palm::metasequoia::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Permission.role)
  return _msg;
}

// .palm.metasequoia.v1.Resource object = 11;
inline bool Permission::_internal_has_object() const {
  return this != internal_default_instance() && _impl_.object_ != nullptr;
}
inline bool Permission::has_object() const {
  return _internal_has_object();
}
inline void Permission::clear_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
}
inline const ::palm::metasequoia::v1::Resource& Permission::_internal_object() const {
  const ::palm::metasequoia::v1::Resource* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Resource&>(
      ::palm::metasequoia::v1::_Resource_default_instance_);
}
inline const ::palm::metasequoia::v1::Resource& Permission::object() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.object)
  return _internal_object();
}
inline void Permission::unsafe_arena_set_allocated_object(
    ::palm::metasequoia::v1::Resource* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Permission.object)
}
inline ::palm::metasequoia::v1::Resource* Permission::release_object() {
  
  ::palm::metasequoia::v1::Resource* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::metasequoia::v1::Resource* Permission::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Permission.object)
  
  ::palm::metasequoia::v1::Resource* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Resource* Permission::_internal_mutable_object() {
  
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Resource>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::palm::metasequoia::v1::Resource* Permission::mutable_object() {
  ::palm::metasequoia::v1::Resource* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Permission.object)
  return _msg;
}
inline void Permission::set_allocated_object(::palm::metasequoia::v1::Resource* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Permission.object)
}

// string action = 12;
inline void Permission::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& Permission::action() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Permission.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Permission::set_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Permission.action)
}
inline std::string* Permission::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Permission.action)
  return _s;
}
inline const std::string& Permission::_internal_action() const {
  return _impl_.action_.Get();
}
inline void Permission::_internal_set_action(const std::string& value) {
  
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* Permission::_internal_mutable_action() {
  
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* Permission::release_action() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Permission.action)
  return _impl_.action_.Release();
}
inline void Permission::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Permission.action)
}

inline bool Permission::has_subject() const {
  return subject_case() != SUBJECT_NOT_SET;
}
inline void Permission::clear_has_subject() {
  _impl_._oneof_case_[0] = SUBJECT_NOT_SET;
}
inline Permission::SubjectCase Permission::subject_case() const {
  return Permission::SubjectCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Resource

// string s = 1;
inline bool Resource::_internal_has_s() const {
  return id_case() == kS;
}
inline bool Resource::has_s() const {
  return _internal_has_s();
}
inline void Resource::set_has_s() {
  _impl_._oneof_case_[0] = kS;
}
inline void Resource::clear_s() {
  if (_internal_has_s()) {
    _impl_.id_.s_.Destroy();
    clear_has_id();
  }
}
inline const std::string& Resource::s() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Resource.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline void Resource::set_s(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_s()) {
    clear_id();
    set_has_s();
    _impl_.id_.s_.InitDefault();
  }
  _impl_.id_.s_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Resource.s)
}
inline std::string* Resource::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Resource.s)
  return _s;
}
inline const std::string& Resource::_internal_s() const {
  if (_internal_has_s()) {
    return _impl_.id_.s_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Resource::_internal_set_s(const std::string& value) {
  if (!_internal_has_s()) {
    clear_id();
    set_has_s();
    _impl_.id_.s_.InitDefault();
  }
  _impl_.id_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_s() {
  if (!_internal_has_s()) {
    clear_id();
    set_has_s();
    _impl_.id_.s_.InitDefault();
  }
  return _impl_.id_.s_.Mutable(      GetArenaForAllocation());
}
inline std::string* Resource::release_s() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Resource.s)
  if (_internal_has_s()) {
    clear_has_id();
    return _impl_.id_.s_.Release();
  } else {
    return nullptr;
  }
}
inline void Resource::set_allocated_s(std::string* s) {
  if (has_id()) {
    clear_id();
  }
  if (s != nullptr) {
    set_has_s();
    _impl_.id_.s_.InitAllocated(s, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Resource.s)
}

// int32 i = 2;
inline bool Resource::_internal_has_i() const {
  return id_case() == kI;
}
inline bool Resource::has_i() const {
  return _internal_has_i();
}
inline void Resource::set_has_i() {
  _impl_._oneof_case_[0] = kI;
}
inline void Resource::clear_i() {
  if (_internal_has_i()) {
    _impl_.id_.i_ = 0;
    clear_has_id();
  }
}
inline int32_t Resource::_internal_i() const {
  if (_internal_has_i()) {
    return _impl_.id_.i_;
  }
  return 0;
}
inline void Resource::_internal_set_i(int32_t value) {
  if (!_internal_has_i()) {
    clear_id();
    set_has_i();
  }
  _impl_.id_.i_ = value;
}
inline int32_t Resource::i() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Resource.i)
  return _internal_i();
}
inline void Resource::set_i(int32_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Resource.i)
}

// string type = 11;
inline void Resource::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Resource::type() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Resource.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Resource::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Resource.type)
}
inline std::string* Resource::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Resource.type)
  return _s;
}
inline const std::string& Resource::_internal_type() const {
  return _impl_.type_.Get();
}
inline void Resource::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* Resource::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* Resource::release_type() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Resource.type)
  return _impl_.type_.Release();
}
inline void Resource::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Resource.type)
}

inline bool Resource::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void Resource::clear_has_id() {
  _impl_._oneof_case_[0] = ID_NOT_SET;
}
inline Resource::IdCase Resource::id_case() const {
  return Resource::IdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Role

// .google.protobuf.Empty administrator = 1;
inline bool Role::_internal_has_administrator() const {
  return by_case() == kAdministrator;
}
inline bool Role::has_administrator() const {
  return _internal_has_administrator();
}
inline void Role::set_has_administrator() {
  _impl_._oneof_case_[0] = kAdministrator;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::release_administrator() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.administrator)
  if (_internal_has_administrator()) {
    clear_has_by();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.by_.administrator_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.by_.administrator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Role::_internal_administrator() const {
  return _internal_has_administrator()
      ? *_impl_.by_.administrator_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Role::administrator() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.administrator)
  return _internal_administrator();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::unsafe_arena_release_administrator() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Role.administrator)
  if (_internal_has_administrator()) {
    clear_has_by();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.by_.administrator_;
    _impl_.by_.administrator_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Role::unsafe_arena_set_allocated_administrator(::PROTOBUF_NAMESPACE_ID::Empty* administrator) {
  clear_by();
  if (administrator) {
    set_has_administrator();
    _impl_.by_.administrator_ = administrator;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Role.administrator)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::_internal_mutable_administrator() {
  if (!_internal_has_administrator()) {
    clear_by();
    set_has_administrator();
    _impl_.by_.administrator_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.by_.administrator_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::mutable_administrator() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_administrator();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.administrator)
  return _msg;
}

// .google.protobuf.Empty root = 2;
inline bool Role::_internal_has_root() const {
  return by_case() == kRoot;
}
inline bool Role::has_root() const {
  return _internal_has_root();
}
inline void Role::set_has_root() {
  _impl_._oneof_case_[0] = kRoot;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::release_root() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.root)
  if (_internal_has_root()) {
    clear_has_by();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.by_.root_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.by_.root_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Role::_internal_root() const {
  return _internal_has_root()
      ? *_impl_.by_.root_
      : reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::Empty&>(::PROTOBUF_NAMESPACE_ID::_Empty_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Empty& Role::root() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.root)
  return _internal_root();
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::unsafe_arena_release_root() {
  // @@protoc_insertion_point(field_unsafe_arena_release:palm.metasequoia.v1.Role.root)
  if (_internal_has_root()) {
    clear_has_by();
    ::PROTOBUF_NAMESPACE_ID::Empty* temp = _impl_.by_.root_;
    _impl_.by_.root_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Role::unsafe_arena_set_allocated_root(::PROTOBUF_NAMESPACE_ID::Empty* root) {
  clear_by();
  if (root) {
    set_has_root();
    _impl_.by_.root_ = root;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.Role.root)
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::_internal_mutable_root() {
  if (!_internal_has_root()) {
    clear_by();
    set_has_root();
    _impl_.by_.root_ = CreateMaybeMessage< ::PROTOBUF_NAMESPACE_ID::Empty >(GetArenaForAllocation());
  }
  return _impl_.by_.root_;
}
inline ::PROTOBUF_NAMESPACE_ID::Empty* Role::mutable_root() {
  ::PROTOBUF_NAMESPACE_ID::Empty* _msg = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.root)
  return _msg;
}

// string code = 3;
inline bool Role::_internal_has_code() const {
  return by_case() == kCode;
}
inline bool Role::has_code() const {
  return _internal_has_code();
}
inline void Role::set_has_code() {
  _impl_._oneof_case_[0] = kCode;
}
inline void Role::clear_code() {
  if (_internal_has_code()) {
    _impl_.by_.code_.Destroy();
    clear_has_by();
  }
}
inline const std::string& Role::code() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.Role.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline void Role::set_code(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_code()) {
    clear_by();
    set_has_code();
    _impl_.by_.code_.InitDefault();
  }
  _impl_.by_.code_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.Role.code)
}
inline std::string* Role::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.Role.code)
  return _s;
}
inline const std::string& Role::_internal_code() const {
  if (_internal_has_code()) {
    return _impl_.by_.code_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Role::_internal_set_code(const std::string& value) {
  if (!_internal_has_code()) {
    clear_by();
    set_has_code();
    _impl_.by_.code_.InitDefault();
  }
  _impl_.by_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_code() {
  if (!_internal_has_code()) {
    clear_by();
    set_has_code();
    _impl_.by_.code_.InitDefault();
  }
  return _impl_.by_.code_.Mutable(      GetArenaForAllocation());
}
inline std::string* Role::release_code() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.Role.code)
  if (_internal_has_code()) {
    clear_has_by();
    return _impl_.by_.code_.Release();
  } else {
    return nullptr;
  }
}
inline void Role::set_allocated_code(std::string* code) {
  if (has_by()) {
    clear_by();
  }
  if (code != nullptr) {
    set_has_code();
    _impl_.by_.code_.InitAllocated(code, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.Role.code)
}

inline bool Role::has_by() const {
  return by_case() != BY_NOT_SET;
}
inline void Role::clear_has_by() {
  _impl_._oneof_case_[0] = BY_NOT_SET;
}
inline Role::ByCase Role::by_case() const {
  return Role::ByCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// User

// int32 id = 1;
inline bool User::_internal_has_id() const {
  return by_case() == kId;
}
inline bool User::has_id() const {
  return _internal_has_id();
}
inline void User::set_has_id() {
  _impl_._oneof_case_[0] = kId;
}
inline void User::clear_id() {
  if (_internal_has_id()) {
    _impl_.by_.id_ = 0;
    clear_has_by();
  }
}
inline int32_t User::_internal_id() const {
  if (_internal_has_id()) {
    return _impl_.by_.id_;
  }
  return 0;
}
inline void User::_internal_set_id(int32_t value) {
  if (!_internal_has_id()) {
    clear_by();
    set_has_id();
  }
  _impl_.by_.id_ = value;
}
inline int32_t User::id() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.User.id)
  return _internal_id();
}
inline void User::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.User.id)
}

// string code = 2;
inline bool User::_internal_has_code() const {
  return by_case() == kCode;
}
inline bool User::has_code() const {
  return _internal_has_code();
}
inline void User::set_has_code() {
  _impl_._oneof_case_[0] = kCode;
}
inline void User::clear_code() {
  if (_internal_has_code()) {
    _impl_.by_.code_.Destroy();
    clear_has_by();
  }
}
inline const std::string& User::code() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.User.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline void User::set_code(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_code()) {
    clear_by();
    set_has_code();
    _impl_.by_.code_.InitDefault();
  }
  _impl_.by_.code_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.User.code)
}
inline std::string* User::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.User.code)
  return _s;
}
inline const std::string& User::_internal_code() const {
  if (_internal_has_code()) {
    return _impl_.by_.code_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void User::_internal_set_code(const std::string& value) {
  if (!_internal_has_code()) {
    clear_by();
    set_has_code();
    _impl_.by_.code_.InitDefault();
  }
  _impl_.by_.code_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_code() {
  if (!_internal_has_code()) {
    clear_by();
    set_has_code();
    _impl_.by_.code_.InitDefault();
  }
  return _impl_.by_.code_.Mutable(      GetArenaForAllocation());
}
inline std::string* User::release_code() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.User.code)
  if (_internal_has_code()) {
    clear_has_by();
    return _impl_.by_.code_.Release();
  } else {
    return nullptr;
  }
}
inline void User::set_allocated_code(std::string* code) {
  if (has_by()) {
    clear_by();
  }
  if (code != nullptr) {
    set_has_code();
    _impl_.by_.code_.InitAllocated(code, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.User.code)
}

inline bool User::has_by() const {
  return by_case() != BY_NOT_SET;
}
inline void User::clear_has_by() {
  _impl_._oneof_case_[0] = BY_NOT_SET;
}
inline User::ByCase User::by_case() const {
  return User::ByCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RbacCanRequest

// int32 user = 1;
inline void RbacCanRequest::clear_user() {
  _impl_.user_ = 0;
}
inline int32_t RbacCanRequest::_internal_user() const {
  return _impl_.user_;
}
inline int32_t RbacCanRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacCanRequest.user)
  return _internal_user();
}
inline void RbacCanRequest::_internal_set_user(int32_t value) {
  
  _impl_.user_ = value;
}
inline void RbacCanRequest::set_user(int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacCanRequest.user)
}

// .palm.metasequoia.v1.Resource object = 2;
inline bool RbacCanRequest::_internal_has_object() const {
  return this != internal_default_instance() && _impl_.object_ != nullptr;
}
inline bool RbacCanRequest::has_object() const {
  return _internal_has_object();
}
inline void RbacCanRequest::clear_object() {
  if (GetArenaForAllocation() == nullptr && _impl_.object_ != nullptr) {
    delete _impl_.object_;
  }
  _impl_.object_ = nullptr;
}
inline const ::palm::metasequoia::v1::Resource& RbacCanRequest::_internal_object() const {
  const ::palm::metasequoia::v1::Resource* p = _impl_.object_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Resource&>(
      ::palm::metasequoia::v1::_Resource_default_instance_);
}
inline const ::palm::metasequoia::v1::Resource& RbacCanRequest::object() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacCanRequest.object)
  return _internal_object();
}
inline void RbacCanRequest::unsafe_arena_set_allocated_object(
    ::palm::metasequoia::v1::Resource* object) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.object_);
  }
  _impl_.object_ = object;
  if (object) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacCanRequest.object)
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::release_object() {
  
  ::palm::metasequoia::v1::Resource* temp = _impl_.object_;
  _impl_.object_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::unsafe_arena_release_object() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacCanRequest.object)
  
  ::palm::metasequoia::v1::Resource* temp = _impl_.object_;
  _impl_.object_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::_internal_mutable_object() {
  
  if (_impl_.object_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Resource>(GetArenaForAllocation());
    _impl_.object_ = p;
  }
  return _impl_.object_;
}
inline ::palm::metasequoia::v1::Resource* RbacCanRequest::mutable_object() {
  ::palm::metasequoia::v1::Resource* _msg = _internal_mutable_object();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacCanRequest.object)
  return _msg;
}
inline void RbacCanRequest::set_allocated_object(::palm::metasequoia::v1::Resource* object) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.object_;
  }
  if (object) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(object);
    if (message_arena != submessage_arena) {
      object = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, object, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.object_ = object;
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacCanRequest.object)
}

// string action = 3;
inline void RbacCanRequest::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& RbacCanRequest::action() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacCanRequest.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RbacCanRequest::set_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacCanRequest.action)
}
inline std::string* RbacCanRequest::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacCanRequest.action)
  return _s;
}
inline const std::string& RbacCanRequest::_internal_action() const {
  return _impl_.action_.Get();
}
inline void RbacCanRequest::_internal_set_action(const std::string& value) {
  
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* RbacCanRequest::_internal_mutable_action() {
  
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* RbacCanRequest::release_action() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacCanRequest.action)
  return _impl_.action_.Release();
}
inline void RbacCanRequest::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacCanRequest.action)
}

// -------------------------------------------------------------------

// RbacHasRequest

// int32 user = 1;
inline void RbacHasRequest::clear_user() {
  _impl_.user_ = 0;
}
inline int32_t RbacHasRequest::_internal_user() const {
  return _impl_.user_;
}
inline int32_t RbacHasRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacHasRequest.user)
  return _internal_user();
}
inline void RbacHasRequest::_internal_set_user(int32_t value) {
  
  _impl_.user_ = value;
}
inline void RbacHasRequest::set_user(int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacHasRequest.user)
}

// .palm.metasequoia.v1.Role role = 2;
inline bool RbacHasRequest::_internal_has_role() const {
  return this != internal_default_instance() && _impl_.role_ != nullptr;
}
inline bool RbacHasRequest::has_role() const {
  return _internal_has_role();
}
inline void RbacHasRequest::clear_role() {
  if (GetArenaForAllocation() == nullptr && _impl_.role_ != nullptr) {
    delete _impl_.role_;
  }
  _impl_.role_ = nullptr;
}
inline const ::palm::metasequoia::v1::Role& RbacHasRequest::_internal_role() const {
  const ::palm::metasequoia::v1::Role* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Role&>(
      ::palm::metasequoia::v1::_Role_default_instance_);
}
inline const ::palm::metasequoia::v1::Role& RbacHasRequest::role() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacHasRequest.role)
  return _internal_role();
}
inline void RbacHasRequest::unsafe_arena_set_allocated_role(
    ::palm::metasequoia::v1::Role* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacHasRequest.role)
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::release_role() {
  
  ::palm::metasequoia::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacHasRequest.role)
  
  ::palm::metasequoia::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::_internal_mutable_role() {
  
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Role>(GetArenaForAllocation());
    _impl_.role_ = p;
  }
  return _impl_.role_;
}
inline ::palm::metasequoia::v1::Role* RbacHasRequest::mutable_role() {
  ::palm::metasequoia::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacHasRequest.role)
  return _msg;
}
inline void RbacHasRequest::set_allocated_role(::palm::metasequoia::v1::Role* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_ = role;
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacHasRequest.role)
}

// -------------------------------------------------------------------

// RbacPermissionItem

// string action = 1;
inline void RbacPermissionItem::clear_action() {
  _impl_.action_.ClearToEmpty();
}
inline const std::string& RbacPermissionItem::action() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionItem.action)
  return _internal_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RbacPermissionItem::set_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacPermissionItem.action)
}
inline std::string* RbacPermissionItem::mutable_action() {
  std::string* _s = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionItem.action)
  return _s;
}
inline const std::string& RbacPermissionItem::_internal_action() const {
  return _impl_.action_.Get();
}
inline void RbacPermissionItem::_internal_set_action(const std::string& value) {
  
  _impl_.action_.Set(value, GetArenaForAllocation());
}
inline std::string* RbacPermissionItem::_internal_mutable_action() {
  
  return _impl_.action_.Mutable(GetArenaForAllocation());
}
inline std::string* RbacPermissionItem::release_action() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacPermissionItem.action)
  return _impl_.action_.Release();
}
inline void RbacPermissionItem::set_allocated_action(std::string* action) {
  if (action != nullptr) {
    
  } else {
    
  }
  _impl_.action_.SetAllocated(action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_.IsDefault()) {
    _impl_.action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacPermissionItem.action)
}

// .palm.metasequoia.v1.Resource resource = 2;
inline bool RbacPermissionItem::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool RbacPermissionItem::has_resource() const {
  return _internal_has_resource();
}
inline void RbacPermissionItem::clear_resource() {
  if (GetArenaForAllocation() == nullptr && _impl_.resource_ != nullptr) {
    delete _impl_.resource_;
  }
  _impl_.resource_ = nullptr;
}
inline const ::palm::metasequoia::v1::Resource& RbacPermissionItem::_internal_resource() const {
  const ::palm::metasequoia::v1::Resource* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Resource&>(
      ::palm::metasequoia::v1::_Resource_default_instance_);
}
inline const ::palm::metasequoia::v1::Resource& RbacPermissionItem::resource() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionItem.resource)
  return _internal_resource();
}
inline void RbacPermissionItem::unsafe_arena_set_allocated_resource(
    ::palm::metasequoia::v1::Resource* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacPermissionItem.resource)
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::release_resource() {
  
  ::palm::metasequoia::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacPermissionItem.resource)
  
  ::palm::metasequoia::v1::Resource* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Resource>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::palm::metasequoia::v1::Resource* RbacPermissionItem::mutable_resource() {
  ::palm::metasequoia::v1::Resource* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionItem.resource)
  return _msg;
}
inline void RbacPermissionItem::set_allocated_resource(::palm::metasequoia::v1::Resource* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.resource_;
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(resource);
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacPermissionItem.resource)
}

// -------------------------------------------------------------------

// RbacPermissionsForUserRequest

// int32 user = 1;
inline void RbacPermissionsForUserRequest::clear_user() {
  _impl_.user_ = 0;
}
inline int32_t RbacPermissionsForUserRequest::_internal_user() const {
  return _impl_.user_;
}
inline int32_t RbacPermissionsForUserRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForUserRequest.user)
  return _internal_user();
}
inline void RbacPermissionsForUserRequest::_internal_set_user(int32_t value) {
  
  _impl_.user_ = value;
}
inline void RbacPermissionsForUserRequest::set_user(int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacPermissionsForUserRequest.user)
}

// repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
inline int RbacPermissionsForUserRequest::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int RbacPermissionsForUserRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void RbacPermissionsForUserRequest::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForUserRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
RbacPermissionsForUserRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return &_impl_.permissions_;
}
inline const ::palm::metasequoia::v1::RbacPermissionItem& RbacPermissionsForUserRequest::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::palm::metasequoia::v1::RbacPermissionItem& RbacPermissionsForUserRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _internal_permissions(index);
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForUserRequest::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForUserRequest::add_permissions() {
  ::palm::metasequoia::v1::RbacPermissionItem* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
RbacPermissionsForUserRequest::permissions() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacPermissionsForUserRequest.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// RbacPermissionsForRoleRequest

// .palm.metasequoia.v1.Role role = 1;
inline bool RbacPermissionsForRoleRequest::_internal_has_role() const {
  return this != internal_default_instance() && _impl_.role_ != nullptr;
}
inline bool RbacPermissionsForRoleRequest::has_role() const {
  return _internal_has_role();
}
inline void RbacPermissionsForRoleRequest::clear_role() {
  if (GetArenaForAllocation() == nullptr && _impl_.role_ != nullptr) {
    delete _impl_.role_;
  }
  _impl_.role_ = nullptr;
}
inline const ::palm::metasequoia::v1::Role& RbacPermissionsForRoleRequest::_internal_role() const {
  const ::palm::metasequoia::v1::Role* p = _impl_.role_;
  return p != nullptr ? *p : reinterpret_cast<const ::palm::metasequoia::v1::Role&>(
      ::palm::metasequoia::v1::_Role_default_instance_);
}
inline const ::palm::metasequoia::v1::Role& RbacPermissionsForRoleRequest::role() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
  return _internal_role();
}
inline void RbacPermissionsForRoleRequest::unsafe_arena_set_allocated_role(
    ::palm::metasequoia::v1::Role* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.role_);
  }
  _impl_.role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::release_role() {
  
  ::palm::metasequoia::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
  
  ::palm::metasequoia::v1::Role* temp = _impl_.role_;
  _impl_.role_ = nullptr;
  return temp;
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::_internal_mutable_role() {
  
  if (_impl_.role_ == nullptr) {
    auto* p = CreateMaybeMessage<::palm::metasequoia::v1::Role>(GetArenaForAllocation());
    _impl_.role_ = p;
  }
  return _impl_.role_;
}
inline ::palm::metasequoia::v1::Role* RbacPermissionsForRoleRequest::mutable_role() {
  ::palm::metasequoia::v1::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
  return _msg;
}
inline void RbacPermissionsForRoleRequest::set_allocated_role(::palm::metasequoia::v1::Role* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.role_ = role;
  // @@protoc_insertion_point(field_set_allocated:palm.metasequoia.v1.RbacPermissionsForRoleRequest.role)
}

// repeated .palm.metasequoia.v1.RbacPermissionItem permissions = 2;
inline int RbacPermissionsForRoleRequest::_internal_permissions_size() const {
  return _impl_.permissions_.size();
}
inline int RbacPermissionsForRoleRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void RbacPermissionsForRoleRequest::clear_permissions() {
  _impl_.permissions_.Clear();
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForRoleRequest::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _impl_.permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >*
RbacPermissionsForRoleRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return &_impl_.permissions_;
}
inline const ::palm::metasequoia::v1::RbacPermissionItem& RbacPermissionsForRoleRequest::_internal_permissions(int index) const {
  return _impl_.permissions_.Get(index);
}
inline const ::palm::metasequoia::v1::RbacPermissionItem& RbacPermissionsForRoleRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _internal_permissions(index);
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForRoleRequest::_internal_add_permissions() {
  return _impl_.permissions_.Add();
}
inline ::palm::metasequoia::v1::RbacPermissionItem* RbacPermissionsForRoleRequest::add_permissions() {
  ::palm::metasequoia::v1::RbacPermissionItem* _add = _internal_add_permissions();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::RbacPermissionItem >&
RbacPermissionsForRoleRequest::permissions() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacPermissionsForRoleRequest.permissions)
  return _impl_.permissions_;
}

// -------------------------------------------------------------------

// RbacRolesForUserRequest

// int32 user = 1;
inline void RbacRolesForUserRequest::clear_user() {
  _impl_.user_ = 0;
}
inline int32_t RbacRolesForUserRequest::_internal_user() const {
  return _impl_.user_;
}
inline int32_t RbacRolesForUserRequest::user() const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacRolesForUserRequest.user)
  return _internal_user();
}
inline void RbacRolesForUserRequest::_internal_set_user(int32_t value) {
  
  _impl_.user_ = value;
}
inline void RbacRolesForUserRequest::set_user(int32_t value) {
  _internal_set_user(value);
  // @@protoc_insertion_point(field_set:palm.metasequoia.v1.RbacRolesForUserRequest.user)
}

// repeated .palm.metasequoia.v1.Role roles = 2;
inline int RbacRolesForUserRequest::_internal_roles_size() const {
  return _impl_.roles_.size();
}
inline int RbacRolesForUserRequest::roles_size() const {
  return _internal_roles_size();
}
inline void RbacRolesForUserRequest::clear_roles() {
  _impl_.roles_.Clear();
}
inline ::palm::metasequoia::v1::Role* RbacRolesForUserRequest::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _impl_.roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
RbacRolesForUserRequest::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return &_impl_.roles_;
}
inline const ::palm::metasequoia::v1::Role& RbacRolesForUserRequest::_internal_roles(int index) const {
  return _impl_.roles_.Get(index);
}
inline const ::palm::metasequoia::v1::Role& RbacRolesForUserRequest::roles(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _internal_roles(index);
}
inline ::palm::metasequoia::v1::Role* RbacRolesForUserRequest::_internal_add_roles() {
  return _impl_.roles_.Add();
}
inline ::palm::metasequoia::v1::Role* RbacRolesForUserRequest::add_roles() {
  ::palm::metasequoia::v1::Role* _add = _internal_add_roles();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
RbacRolesForUserRequest::roles() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacRolesForUserRequest.roles)
  return _impl_.roles_;
}

// -------------------------------------------------------------------

// RbacRolesResponse

// repeated .palm.metasequoia.v1.Role items = 1;
inline int RbacRolesResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RbacRolesResponse::items_size() const {
  return _internal_items_size();
}
inline void RbacRolesResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::palm::metasequoia::v1::Role* RbacRolesResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacRolesResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >*
RbacRolesResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacRolesResponse.items)
  return &_impl_.items_;
}
inline const ::palm::metasequoia::v1::Role& RbacRolesResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::palm::metasequoia::v1::Role& RbacRolesResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacRolesResponse.items)
  return _internal_items(index);
}
inline ::palm::metasequoia::v1::Role* RbacRolesResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::palm::metasequoia::v1::Role* RbacRolesResponse::add_items() {
  ::palm::metasequoia::v1::Role* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacRolesResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Role >&
RbacRolesResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacRolesResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// RbacPermissionsResponse

// repeated .palm.metasequoia.v1.Permission items = 1;
inline int RbacPermissionsResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RbacPermissionsResponse::items_size() const {
  return _internal_items_size();
}
inline void RbacPermissionsResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::palm::metasequoia::v1::Permission* RbacPermissionsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Permission >*
RbacPermissionsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return &_impl_.items_;
}
inline const ::palm::metasequoia::v1::Permission& RbacPermissionsResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::palm::metasequoia::v1::Permission& RbacPermissionsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _internal_items(index);
}
inline ::palm::metasequoia::v1::Permission* RbacPermissionsResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::palm::metasequoia::v1::Permission* RbacPermissionsResponse::add_items() {
  ::palm::metasequoia::v1::Permission* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::Permission >&
RbacPermissionsResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacPermissionsResponse.items)
  return _impl_.items_;
}

// -------------------------------------------------------------------

// RbacUsersResponse

// repeated .palm.metasequoia.v1.User items = 1;
inline int RbacUsersResponse::_internal_items_size() const {
  return _impl_.items_.size();
}
inline int RbacUsersResponse::items_size() const {
  return _internal_items_size();
}
inline void RbacUsersResponse::clear_items() {
  _impl_.items_.Clear();
}
inline ::palm::metasequoia::v1::User* RbacUsersResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:palm.metasequoia.v1.RbacUsersResponse.items)
  return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::User >*
RbacUsersResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:palm.metasequoia.v1.RbacUsersResponse.items)
  return &_impl_.items_;
}
inline const ::palm::metasequoia::v1::User& RbacUsersResponse::_internal_items(int index) const {
  return _impl_.items_.Get(index);
}
inline const ::palm::metasequoia::v1::User& RbacUsersResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:palm.metasequoia.v1.RbacUsersResponse.items)
  return _internal_items(index);
}
inline ::palm::metasequoia::v1::User* RbacUsersResponse::_internal_add_items() {
  return _impl_.items_.Add();
}
inline ::palm::metasequoia::v1::User* RbacUsersResponse::add_items() {
  ::palm::metasequoia::v1::User* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:palm.metasequoia.v1.RbacUsersResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::palm::metasequoia::v1::User >&
RbacUsersResponse::items() const {
  // @@protoc_insertion_point(field_list:palm.metasequoia.v1.RbacUsersResponse.items)
  return _impl_.items_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace metasequoia
}  // namespace palm

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_metasequoia_2eproto
